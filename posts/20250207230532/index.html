<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ 如何排查多线程中的死锁问题？ | 个人博客</title>
<meta name=keywords content="cpp"><meta name=description content="摘要：本文介绍了死锁产生的原因，并提供了多种排查和解决多线程死锁问题的方法，包括使用调试工具、代码审查、日志记录以及优化锁机制等。"><meta name=author content="Yangly0"><link rel=canonical href=https://yangly0.github.io/posts/20250207230532/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://yangly0.github.io/images/favicon/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://yangly0.github.io/images/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangly0.github.io/images/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yangly0.github.io/images/favicon/apple-touch-icon.png><link rel=mask-icon href=https://yangly0.github.io/images/favicon/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yangly0.github.io/posts/20250207230532/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://yangly0.github.io/posts/20250207230532/"><meta property="og:site_name" content="个人博客"><meta property="og:title" content="C++ 如何排查多线程中的死锁问题？"><meta property="og:description" content="摘要：本文介绍了死锁产生的原因，并提供了多种排查和解决多线程死锁问题的方法，包括使用调试工具、代码审查、日志记录以及优化锁机制等。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-07T23:05:32+00:00"><meta property="article:modified_time" content="2025-02-07T23:05:32+00:00"><meta property="article:tag" content="Cpp"><meta property="og:image" content="https://yangly0.github.io/images/favicon/favicon.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yangly0.github.io/images/favicon/favicon.png"><meta name=twitter:title content="C++ 如何排查多线程中的死锁问题？"><meta name=twitter:description content="摘要：本文介绍了死锁产生的原因，并提供了多种排查和解决多线程死锁问题的方法，包括使用调试工具、代码审查、日志记录以及优化锁机制等。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yangly0.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ 如何排查多线程中的死锁问题？","item":"https://yangly0.github.io/posts/20250207230532/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 如何排查多线程中的死锁问题？","name":"C\u002b\u002b 如何排查多线程中的死锁问题？","description":"摘要：本文介绍了死锁产生的原因，并提供了多种排查和解决多线程死锁问题的方法，包括使用调试工具、代码审查、日志记录以及优化锁机制等。\n","keywords":["cpp"],"articleBody":"摘要：本文介绍了死锁产生的原因，并提供了多种排查和解决多线程死锁问题的方法，包括使用调试工具、代码审查、日志记录以及优化锁机制等。\n0x01 原因 当多个线程因为竞争资源而陷入相互等待的状态时，导致无法继续执行，就发生了线程死锁。\n死锁产生条件：\n互斥条件：资源不能被共享，只能被一个线程占用。 请求与保持条件：线程已经持有一个资源，同时请求另一个资源。 不可剥夺条件：线程持有的资源不能被其他线程强制剥夺。 循环等待条件：存在一个线程等待链，形成循环。 0x02 排查方案 Kimi大模型提供的几个思路：\nVisual Studio 支持多线程调试，可以通过线程窗口查看所有线程的状态，或者通过并发可视化器直观地显示线程的执行和同步状态，甚至诊断工具可以自动检测死锁； GDB调试，info thread 列出所有线程及其状态，并跳转到指定线程查看其调用栈； 类似Intel Inspector 的内存和线程检查工具，可以检测死锁、竞态条件等问题； 正向走读代码，关注锁的地方，是否存在多个锁的顺序不一致、嵌套锁等问题； 在多线程代码中添加详细的日志记录，可以帮助你追踪线程的执行路径和锁的状态。 实际环境，平台运行差异无法使用（1）和（3）方案。多线程问题往往是偶发的，方案（5）也无法有效实施。Release版本也不支持GDB调试，方案（2）也无法实施。因此，这里提供几条个人经验：\nTop -H 查看线程cpu，可以比较线程前后cpu变化，初判断是那个线程异常。 利用core文件机制，对死锁进程发送信号生成core文件kill -SIGSEGV ，再用GDB对core文件调试，查看线程调用栈。 同步组建专家团队，正向走读代码，关注锁的使用。 同步添加详细日志，持续压测复现该问题。 同步类似Coverity等软件静态扫描代码。 0x03 规避方案 1、使用锁的超时机制：在某些情况下，可以使用带超时的锁机制（如 std::timed_mutex），以避免线程永久阻塞\n2、减少锁的使用：在设计多线程程序时，尽量减少锁的使用，或者使用无锁编程技术。例如，可以使用原子操作（如 std::atomic）来避免锁的使用。\n","wordCount":"39","inLanguage":"en","image":"https://yangly0.github.io/images/favicon/favicon.png","datePublished":"2025-02-07T23:05:32Z","dateModified":"2025-02-07T23:05:32Z","author":{"@type":"Person","name":"Yangly0"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangly0.github.io/posts/20250207230532/"},"publisher":{"@type":"Organization","name":"个人博客","logo":{"@type":"ImageObject","url":"https://yangly0.github.io/images/favicon/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangly0.github.io/ accesskey=h title="个人博客 (Alt + H)">个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangly0.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://yangly0.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yangly0.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://yangly0.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">C++ 如何排查多线程中的死锁问题？</h1><div class=post-meta><span title='2025-02-07 23:05:32 +0000 UTC'>February 7, 2025</span>&nbsp;·&nbsp;Yangly0</div></header><div class=post-content><p>摘要：本文介绍了死锁产生的原因，并提供了多种排查和解决多线程死锁问题的方法，包括使用调试工具、代码审查、日志记录以及优化锁机制等。</p><h2 id=0x01-原因>0x01 原因<a hidden class=anchor aria-hidden=true href=#0x01-原因>#</a></h2><p>当多个线程因为竞争资源而陷入相互等待的状态时，导致无法继续执行，就发生了线程死锁。</p><p>死锁产生条件：</p><ol><li>互斥条件：资源不能被共享，只能被一个线程占用。</li><li>请求与保持条件：线程已经持有一个资源，同时请求另一个资源。</li><li>不可剥夺条件：线程持有的资源不能被其他线程强制剥夺。</li><li>循环等待条件：存在一个线程等待链，形成循环。</li></ol><h2 id=0x02-排查方案>0x02 排查方案<a hidden class=anchor aria-hidden=true href=#0x02-排查方案>#</a></h2><p>Kimi大模型提供的几个思路：</p><ol><li>Visual Studio 支持多线程调试，可以通过线程窗口查看所有线程的状态，或者通过并发可视化器直观地显示线程的执行和同步状态，甚至诊断工具可以自动检测死锁；</li><li>GDB调试，<code>info thread</code> 列出所有线程及其状态，并跳转到指定线程查看其调用栈；</li><li>类似Intel Inspector 的内存和线程检查工具，可以检测死锁、竞态条件等问题；</li><li>正向走读代码，关注锁的地方，是否存在多个锁的顺序不一致、嵌套锁等问题；</li><li>在多线程代码中添加详细的日志记录，可以帮助你追踪线程的执行路径和锁的状态。</li></ol><p>实际环境，平台运行差异无法使用（1）和（3）方案。多线程问题往往是偶发的，方案（5）也无法有效实施。Release版本也不支持GDB调试，方案（2）也无法实施。因此，这里提供几条个人经验：</p><ol start=5><li>Top -H 查看线程cpu，可以比较线程前后cpu变化，初判断是那个线程异常。</li><li>利用core文件机制，对死锁进程发送信号生成core文件<code>kill -SIGSEGV &lt;pid></code>，再用GDB对core文件调试，查看线程调用栈。</li><li>同步组建专家团队，正向走读代码，关注锁的使用。</li><li>同步添加详细日志，持续压测复现该问题。</li><li>同步类似Coverity等软件静态扫描代码。</li></ol><h2 id=0x03-规避方案>0x03 规避方案<a hidden class=anchor aria-hidden=true href=#0x03-规避方案>#</a></h2><p>1、使用锁的超时机制：在某些情况下，可以使用带超时的锁机制（如 std::timed_mutex），以避免线程永久阻塞</p><p>2、减少锁的使用：在设计多线程程序时，尽量减少锁的使用，或者使用无锁编程技术。例如，可以使用原子操作（如 std::atomic）来避免锁的使用。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangly0.github.io/tags/cpp/>Cpp</a></li></ul><nav class=paginav><a class=prev href=https://yangly0.github.io/posts/20250207233212/><span class=title>« Prev</span><br><span>c++ 模板偏特化</span>
</a><a class=next href=https://yangly0.github.io/posts/20250206094054/><span class=title>Next »</span><br><span>速读论文M2BEV</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Yangly0/hugo-utterances issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>