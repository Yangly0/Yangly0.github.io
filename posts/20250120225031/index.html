<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>设计模式之策略模式 | 个人博客</title>
<meta name=keywords content="编程,cpp"><meta name=description content="摘要：一种设计模式——策略模式！"><meta name=author content="Yangly0"><link rel=canonical href=https://yangly0.github.io/posts/20250120225031/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://yangly0.github.io/images/favicon/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://yangly0.github.io/images/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangly0.github.io/images/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yangly0.github.io/images/favicon/apple-touch-icon.png><link rel=mask-icon href=https://yangly0.github.io/images/favicon/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yangly0.github.io/posts/20250120225031/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://yangly0.github.io/posts/20250120225031/"><meta property="og:site_name" content="个人博客"><meta property="og:title" content="设计模式之策略模式"><meta property="og:description" content="摘要：一种设计模式——策略模式！"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-20T22:50:31+00:00"><meta property="article:modified_time" content="2025-01-20T22:50:31+00:00"><meta property="article:tag" content="编程"><meta property="article:tag" content="Cpp"><meta property="og:image" content="https://yangly0.github.io/images/favicon/favicon.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yangly0.github.io/images/favicon/favicon.png"><meta name=twitter:title content="设计模式之策略模式"><meta name=twitter:description content="摘要：一种设计模式——策略模式！"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yangly0.github.io/posts/"},{"@type":"ListItem","position":2,"name":"设计模式之策略模式","item":"https://yangly0.github.io/posts/20250120225031/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"设计模式之策略模式","name":"设计模式之策略模式","description":"摘要：一种设计模式——策略模式！\n","keywords":["编程","cpp"],"articleBody":"摘要：一种设计模式——策略模式！\npolicy-base的做法是正交分割+多继承+模版限定上下文\n1、继承：基类定义接口，子类进行实现。缺点是派生类过多，更深层次的继承结构，两个类似实现重复，造成难于扩展和维护。\nclass animal; class dog: public animal{ void call(int times) const override; }; 2、策略模式：采用模板实现重载，进行类型分发，如不同迭代器类型，std:advacne的策略不同。可以在模板中指定特殊的策略，比如std:priority_queue默认是大根堆，可以在模板指定不同策略；unique_ptr+的deleter可以自己指定删除策略。\nclass dog; class dog_strategy{ virtual void call(const dog\u0026 d, int time) const = 0; }; class dog:public animal{ dog(..., std::qunique_ptr\u003cdog_strategy\u003e s) :calling(std::move(s)) {} void call(int times) const override{ calling-\u003ecall(*this,times); } std::unique_ptr\u003cdog_strategy\u003e calling; }; class Husky_strategy : public dog_strategy; // std::unique_ptr = std::make_unique","wordCount":"164","inLanguage":"en","image":"https://yangly0.github.io/images/favicon/favicon.png","datePublished":"2025-01-20T22:50:31Z","dateModified":"2025-01-20T22:50:31Z","author":{"@type":"Person","name":"Yangly0"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yangly0.github.io/posts/20250120225031/"},"publisher":{"@type":"Organization","name":"个人博客","logo":{"@type":"ImageObject","url":"https://yangly0.github.io/images/favicon/favicon.png"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://yangly0.github.io/ accesskey=h title="个人博客 (Alt + H)">个人博客</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://yangly0.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://yangly0.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yangly0.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://yangly0.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">设计模式之策略模式</h1><div class=post-meta><span title='2025-01-20 22:50:31 +0000 UTC'>January 20, 2025</span>&nbsp;·&nbsp;Yangly0</div></header><div class=post-content><p>摘要：一种设计模式——策略模式！</p><p>policy-base的做法是正交分割+多继承+模版限定上下文</p><p>1、继承：基类定义接口，子类进行实现。缺点是派生类过多，更深层次的继承结构，两个类似实现重复，造成难于扩展和维护。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>animal</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>dog</span><span class=o>:</span> <span class=k>public</span> <span class=n>animal</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>call</span><span class=p>(</span><span class=kt>int</span> <span class=n>times</span><span class=p>)</span> <span class=k>const</span> <span class=k>override</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>2、策略模式：采用模板实现重载，进行类型分发，如不同迭代器类型，std:advacne的策略不同。可以在模板中指定特殊的策略，比如std:priority_queue默认是大根堆，可以在模板指定不同策略；unique_ptr+的deleter可以自己指定删除策略。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>dog</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>dog_strategy</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>call</span><span class=p>(</span><span class=k>const</span> <span class=n>dog</span><span class=o>&amp;</span> <span class=n>d</span><span class=p>,</span> <span class=kt>int</span> <span class=n>time</span><span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>dog</span><span class=o>:</span><span class=k>public</span> <span class=n>animal</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>dog</span><span class=p>(...,</span> <span class=n>std</span><span class=o>::</span><span class=n>qunique_ptr</span><span class=o>&lt;</span><span class=n>dog_strategy</span><span class=o>&gt;</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span><span class=n>calling</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>s</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{}</span>
</span></span><span class=line><span class=cl> 	<span class=kt>void</span> <span class=nf>call</span><span class=p>(</span><span class=kt>int</span> <span class=n>times</span><span class=p>)</span> <span class=k>const</span> <span class=k>override</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>calling</span><span class=o>-&gt;</span><span class=n>call</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>,</span><span class=n>times</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>dog_strategy</span><span class=o>&gt;</span> <span class=n>calling</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Husky_strategy</span> <span class=o>:</span> <span class=k>public</span> <span class=n>dog_strategy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// std::unique_ptr&lt;animal&gt; = std::make_unique&lt;dog(0,std::make_unique&lt;Husky_strategy&gt;());
</span></span></span></code></pre></div><p>3、类型擦除：借助两个类型，实现类型擦除</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>calling</span><span class=p>(</span><span class=k>const</span> <span class=n>Husky</span><span class=o>&amp;</span> <span class=n>d</span><span class=p>,</span><span class=kt>int</span> <span class=n>times</span><span class=p>){}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>calling</span><span class=p>(</span><span class=k>const</span> <span class=n>Siamese</span><span class=o>&amp;</span> <span class=n>d</span><span class=p>,</span><span class=kt>int</span> <span class=n>times</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>animal</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>animal_concept</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>animal_concept</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>call</span><span class=p>(</span><span class=kt>int</span> <span class=n>times</span><span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>animal_concept</span><span class=o>&gt;</span> <span class=n>clone</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>animal</span> <span class=n>model</span> <span class=k>public</span> <span class=n>animal</span> <span class=k>concept</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span><span class=n>Args</span><span class=o>&gt;</span>            <span class=n>animal_model</span><span class=p>(</span><span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span><span class=n>val</span><span class=p>)</span><span class=n>object</span><span class=p>(</span><span class=nl>std</span><span class=p>:</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>val</span><span class=p>)...){}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>    <span class=nl>std</span><span class=p>:</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>animal_concept</span><span class=o>&gt;</span><span class=n>clone</span><span class=err>（）</span><span class=k>const</span> <span class=k>override</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nl>std</span><span class=p>:</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>animal_model</span><span class=o>&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=nf>call</span><span class=p>(</span><span class=kt>int</span> <span class=n>times</span><span class=p>)</span><span class=k>const</span> <span class=k>override</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>calling</span><span class=p>(</span><span class=n>object</span><span class=p>,</span><span class=n>times</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>T</span> <span class=n>object</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=k>friend</span> <span class=kt>void</span> <span class=nf>call</span><span class=p>(</span><span class=k>const</span> <span class=n>animal</span><span class=o>&amp;</span><span class=n>a</span><span class=p>,</span><span class=kt>int</span> <span class=n>times</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=n>a</span><span class=p>.</span><span class=n>pimpl</span><span class=o>-&gt;</span><span class=n>call</span><span class=p>(</span><span class=n>times</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nl>std</span><span class=p>:</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>animal_concept</span><span class=o>&gt;</span><span class=n>pimpl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>	<span class=n>animal</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;&amp;</span><span class=n>x</span><span class=p>)</span><span class=o>:</span><span class=n>pimpl</span><span class=p>{</span><span class=k>new</span> <span class=n>animal_model</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=nl>std</span><span class=p>:</span><span class=n>move</span><span class=p>(</span><span class=n>x</span><span class=p>))}{}</span>
</span></span><span class=line><span class=cl>	<span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>	<span class=n>animal</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span><span class=n>x</span><span class=p>)</span><span class=o>:</span><span class=n>pimpl</span><span class=p>{</span><span class=k>new</span> <span class=n>animal_model</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>x</span><span class=p>)}{}</span>
</span></span><span class=line><span class=cl>	<span class=n>animal</span><span class=p>(</span><span class=k>const</span> <span class=n>animal</span><span class=o>&amp;</span><span class=n>other</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>animal</span><span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>animal</span><span class=o>&amp;</span><span class=n>other</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>animal</span><span class=p>(</span><span class=n>animal</span><span class=o>&amp;&amp;</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>animal</span><span class=o>&amp;</span><span class=k>operator</span><span class=o>+=</span><span class=p>(</span><span class=n>animal</span><span class=o>&amp;&amp;</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>using animals std:vector&lt;animal&gt;;
</span></span></span><span class=line><span class=cl><span class=cm>animals as;
</span></span></span><span class=line><span class=cl><span class=cm>as.emplace_back(dog{1));
</span></span></span><span class=line><span class=cl><span class=cm>as.emplace_back(cat{1));
</span></span></span><span class=line><span class=cl><span class=cm>as.emplace_back(Husky{2});
</span></span></span><span class=line><span class=cl><span class=cm>as.emplace_back(Siamese{3});
</span></span></span><span class=line><span class=cl><span class=cm>as.emplace_back(Bulldog{6});
</span></span></span><span class=line><span class=cl><span class=cm>for(const auto&amp;a as){
</span></span></span><span class=line><span class=cl><span class=cm>	ca11(a,4);
</span></span></span><span class=line><span class=cl><span class=cm>}
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><ul><li>:[^01] ref: <a href=https://www.zhihu.com/question/37391884/answer/3520221395>fr1vol-策略模式-知乎</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://yangly0.github.io/tags/%E7%BC%96%E7%A8%8B/>编程</a></li><li><a href=https://yangly0.github.io/tags/cpp/>Cpp</a></li></ul><nav class=paginav><a class=prev href=https://yangly0.github.io/posts/20250205211553/><span class=title>« Prev</span><br><span>速读论文Fast-Bev</span>
</a><a class=next href=https://yangly0.github.io/posts/20250120223603/><span class=title>Next »</span><br><span>pimpl模式</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=Yangly0/hugo-giscus data-repo-id=R_kgDON69qdw data-category=Announcements data-category-id=DIC_kwDON69qd84CnC5n data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=noborder_light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script></body></html>