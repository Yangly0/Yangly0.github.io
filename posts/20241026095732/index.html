<!DOCTYPE html>
<html lang="zh" dir="auto" data-theme="light">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>数据结构与算法 个人篇 | 所见所思</title>
<meta name="keywords" content="技术, 数据结构与算法">
<meta name="description" content="摘要：本文是个人日常对数据结构与算法的学习内容。">
<meta name="author" content="Yangly">
<link rel="canonical" href="https://yangly0.github.io/posts/20241026095732/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://yangly0.github.io/images/avatar.webp">
<link rel="icon" type="image/png" sizes="16x16" href="https://yangly0.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yangly0.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://yangly0.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://yangly0.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://yangly0.github.io/posts/20241026095732/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css"
    integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js"
    integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js"
    integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    });
</script> 
<meta property="og:url" content="https://yangly0.github.io/posts/20241026095732/">
  <meta property="og:site_name" content="所见所思">
  <meta property="og:title" content="数据结构与算法 个人篇">
  <meta property="og:description" content="摘要：本文是个人日常对数据结构与算法的学习内容。">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-10-26T09:57:32+00:00">
    <meta property="article:modified_time" content="2024-10-26T09:57:32+00:00">
    <meta property="article:tag" content="技术">
    <meta property="article:tag" content="数据结构与算法">
      <meta property="og:image" content="https://yangly0.github.io/images/avatar.webp">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yangly0.github.io/images/avatar.webp">
<meta name="twitter:title" content="数据结构与算法 个人篇">
<meta name="twitter:description" content="摘要：本文是个人日常对数据结构与算法的学习内容。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://yangly0.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "数据结构与算法 个人篇",
      "item": "https://yangly0.github.io/posts/20241026095732/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据结构与算法 个人篇",
  "name": "数据结构与算法 个人篇",
  "description": "摘要：本文是个人日常对数据结构与算法的学习内容。\n",
  "keywords": [
    "技术", "数据结构与算法"
  ],
  "articleBody": "摘要：本文是个人日常对数据结构与算法的学习内容。\n模板 参考AcWing和OI Wiki，几乎所有数据结构和算法都有相应模板。\n输入输出 ref：OJ的自我修养：C++输入输出总结_c++ oj的输入输出-CSDN博客\n#include //全部头文件，必备 using namespace std; // 命名空间 // c语言 int n; while(scanf(\"%d\", \u0026n) != EOF \u0026\u0026 n!= 0){ int a, b; for(int i=0; i \u003c n; ++i){ scanf(\"%d%d\", \u0026a, \u0026b); // 注意点，引用 printf(\"%d %d\\n\", a, b); } } // c++语言 /*\u003e\u003e 数值带定长 */ int n, a; while(cin \u003e\u003e n){ // 忽略空格，回车，Tab，遇到EOF会跳出循环 for(int i=0; i \u003c n; ++i){ cin \u003e\u003e a; cout \u003c\u003c a \u003c\u003c ' '; } cout \u003c\u003c '\\n'; } /*\u003e\u003e 数值带不定长 */ int m, b; cin \u003e\u003e m; for (int i = 0; i \u003c m; i++) { while (cin \u003e\u003e b) { cout \u003c\u003c b \u003c\u003c ' '; if (getchar() == '\\n'){ // 遇到回车结束 cout \u003c\u003c '\\n'; break; } } } /*\u003e\u003e 字符串 */ string str; cin \u003e\u003e str; // cin遇到空格结束读取 /*\u003e\u003e 字符串带空格 */ string str; // getline函数可以获取包含空格的字符，以回车键结束 while(getline(cin, str)){ // 遇到EOF或者CTRL+Z退出 cout \u003c str \u003c\u003c '\\n'; } /*\u003e\u003e 字符串带逗号 */ string strs, str; cin \u003e\u003e strs; stringstream input(strs); while(getline(input, str, ',')){ cout \u003c\u003c str \u003c\u003c ' '; } cout \u003c\u003c '\\n'; // python 版本 while True: try: n = int(input()) for _ in range(n): lis = list(map(int, input().split())) print(sum(lis[1:])) except: break 数据结构 有序数组 区间范围值$[l,r]$：upper_bounder(…,…,r) - lower_bounder(…,…,l)\n链表 定义：链表是一种线性数据结构。链表中的每个元素实际上是一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起。\n单链表：1、与数组的区别，$O(N)$查询，$O(1)$插入和删除；2、注意的是头节点处理；3、经典问题：反转链表、移除链表元素、奇偶链表、回文链表（快慢双指针）。\nstruct ListNode{ int val; ListNode *next; ListNode(int x):val(x), next(NULL){} }; // head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init(){ head = -1; idx = 0; } // 在链表头插入一个数a void insert(int a){ e[idx] = a, ne[idx] = head, head = idx++; } // 将头结点删除，需要保证头结点存在 void remove(){ head = ne[head]; } 双链表：1、与数组的区别，最坏情况下$O(N)$查询，$O(1)$插入和删除；2、注意的是头节点和尾节点处理；3、经典题型：扁平化多级双向链表、复制带随机指针的链表、旋转链表。\nstruct DoublyListNode { int val; DoublyListNode *next, *prev; DoublyListNode(int x) : val(x), next(NULL), prev(NULL) {} }; // e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init(){ //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2; } // 在节点a的右边插入一个数x void insert(int a, int x){ e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ; } // 删除节点a void remove(int a){ l[r[a]] = l[a]; r[l[a]] = r[a]; } 哈希表 哈希表是一种键值对的数据结构，它使用哈希函数组织数据，以支持快速插入和搜索。具体实现上，利用哈希函数将键映射到存储桶。更确切地说，当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；反之，当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。\n实现方式：拉链法和开放寻址法。\n开放寻址法：将冲突的键值对直接存储在哈希表中的其他位置。当发生冲突时，通过一定的探测序列（不同步长，如线性探测、二次探测等），在哈希表中寻找下一个可用的位置进行存储并特殊标记。\n插入数据：当我们往散列表中插入数据时，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。 查找数据：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则，就顺序往后依次查找。如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。 删除数据：为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。最坏时间复杂度为O(n)。 二次探测（Quadratic probing）：线性探测每次探测的步长为1，即在数组中一个一个探测，而二次探测的步长变为原来的平方。 双重散列（Double hashing）：使用一组散列函数，直到找到空闲位置为止。线性探测法的性能描述：用“装载因子”来表示空位多少，公式：散列表装载因子=填入表中的个数/散列表的长度。装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。 链表法：哈希表中的每个桶都是一个链表，当发生冲突时，新的键值对将被插入到链表的末尾。\n插入数据：当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)； 查找或删除数据：当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中槽的个数，所以是时间复杂度为O(k)。 让我们假设存储最大键数的桶有 N 个键。通常，如果 N 是常数且很小，我们可以简单地使用一个数组将键存储在同一个桶中。如果 N 是可变的或很大，我们可能需要使用高度平衡的二叉树（红黑树）来代替。 再哈希法：使用不同的哈希函数来计算冲突键值对的哈希值。当发生冲突时，再次使用另一个哈希函数进行计算，直到找到一个可用的位置。\n伪随机探测再散列：当发生哈希冲突时，伪随机探测再散列使用不同的探测序列来计算下一个可用的位置。它可以降低哈希表的聚集性，增加键值对的分散程度。\n线性探测再散列：当发生哈希冲突时，通过逐个位置地查找下一个可用的位置来解决冲突。如果当前位置已被占用，则线性探测再散列算法会继续查找下一个位置，直到找到一个空闲的位置来存储冲突键值对。\n(1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x){ int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在 bool find(int x){ int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } (2) 开放寻址法 int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x){ int t = (x % N + N) % N; while (h[t] != null \u0026\u0026 h[t] != x) { t++ ; if (t == N) t = 0; } return t; } 栈 定义：操作受限的线性表，限定仅在表后端（栈顶）进行插入和删除操作的线性表。1、先进后出；2、显式栈实现 DFS。\n// tt表示栈顶 int stk[N], tt = 0; // 向栈顶插入一个数 stk[++tt] = x; // 从栈顶弹出一个数 tt--; // 栈顶的值 cout \u003c\u003c stk[tt] \u003c\u003c endl; // 判断栈是否为空 if (tt \u003e 0) { // todo } 单调栈：\n// 常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; while (tt \u0026\u0026 check(stk[tt], x)) tt--; // check: 比它大/小的判断 stk[++tt] = i; 队列 定义：操作受限制的线性表，受限于只能在表前端删除（队头），表后端删除操作（对尾）。1、先进先出。\n普遍队列：\n// hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[++tt] = x; // 从队头弹出一个数 hh++; // 队头的值 q[hh]; // 判断队列是否为空 if (hh \u003c= tt) { // todo } 循环队列：\n// hh 表示队头，tt表示队尾的后一个位置 int q[N], hh = 0, tt = 0; // 向队尾插入一个数 q[tt++ ] = x; if (tt == N) tt = 0; // 从队头弹出一个数 hh++ ; if (hh == N) hh = 0; // 队头的值 q[hh]; // 判断队列是否为空 if (hh != tt){ // todo } 单调队列 单调队列：deque，右边与当前值比较，增加当前值，左边与size比较。239. 滑动窗口最大值\n// 常见模型：找出滑动窗口中的最大值/最小值 int hh = 0, tt = -1; for (int i = 0; i \u003c n; i ++ ){ // 判断队头是否滑出窗口 while (hh \u003c= tt \u0026\u0026 check_out(q[hh])) hh++; while (hh \u003c= tt \u0026\u0026 check(q[tt], i)) tt--; q[ ++ tt] = i; } 堆 定义：一种由完全二叉树构成的数组对象数据结构，堆中某个结点的值总是不大于或不小于其父结点的值。\n// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // ph[k]存储第k个插入的点在堆中的位置 // hp[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b){ swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u){ int t = u; if (u * 2 \u003c= size \u0026\u0026 h[u * 2] \u003c h[t]) t = u * 2; if (u * 2 + 1 \u003c= size \u0026\u0026 h[u * 2 + 1] \u003c h[t]) t = u * 2 + 1; if (u != t) { heap_swap(u, t); down(t); } } void up(int u){ while (u / 2 \u0026\u0026 h[u] \u003c h[u / 2]) { heap_swap(u, u / 2); u \u003e\u003e= 1; } } // O(n)建堆 for (int i = n / 2; i; i--) down(i); 树 定义：树是一种非线性的数据结构,它是由n(n\u003e=0)个有限节点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它跟朝上，而叶朝下。\n类别：二叉树（每个节点至多两棵子树）、二叉搜索树（左\u003c根\u003c右）、满二叉树（‌每层结点数均达最大值的二叉树）、完全二叉树（除最后一层外每层节点数达到最大，且最后一层节点连续左对齐）、平衡二叉树（AVL树，它的任意结点的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1）、红黑树（自平衡的二叉搜索树‌，节点要么是红色要么是黑色，根节点必须是黑色且叶子节点是黑色，相同颜色节点不能相邻，每个节点到叶子节点的黑色节点数量相同）、N叉树\n遍历：前序遍历（根左右）、中序遍（左根右）、后序遍历（左右根）、层序遍历、垂序遍历\n重构：前序和中序、中序和后序、前序和后序。思路细节：1. 提前用数组记录每个节点索引；2. 左子树的大小；\n祖先：1483. 树节点的第 K 个祖先 - 力扣（LeetCode）\nclass TreeAncestor { vector\u003cvector\u003cint\u003e\u003e pa; public: TreeAncestor(int n, vector\u003cint\u003e \u0026parent) { int m = 32 - __builtin_clz(n); // n 的二进制长度 pa.resize(n, vector\u003cint\u003e(m, -1)); for (int i = 0; i \u003c n; i++) pa[i][0] = parent[i]; for (int i = 0; i \u003c m - 1; i++) for (int x = 0; x \u003c n; x++) if (int p = pa[x][i]; p != -1) pa[x][i + 1] = pa[p][i]; } int getKthAncestor(int node, int k) { int m = 32 - __builtin_clz(k); // k 的二进制长度 for (int i = 0; i \u003c m; i++) { if ((k \u003e\u003e i) \u0026 1) { // k 的二进制从低到高第 i 位是 1 node = pa[node][i]; if (node \u003c 0) break; } } return node; } }; x和y的公共祖先：倍增法\n// 返回 x 和 y 的最近公共祖先（节点编号从 0 开始）0 1 2 3 4 int get_lca(int x, int y) { // x=2 y=3 if (depth[x] \u003e depth[y]) swap(x, y); // 使 y 和 x 在同一深度 y = get_kth_ancestor(y, depth[y] - depth[x]); // y = 1 x = 2 if (y == x) return x; // 不相等， for (int i = pa[x].size() - 1; i \u003e= 0; i--) { int px = pa[x][i], py = pa[y][i]; if (px != py) { // 不相等，最近公共祖先在更上一层，需要x和y往上一起跳，直到相等；相等，那么最近公共祖可能在pa[x][i]下面，由于无法往下跳，只能将i减一。 x = px; y = py; } } return pa[x][0]; } 换根DP：【图解】一张图秒懂换根 DP！\n原理：从0出发DFS，累加0到每个点的距离，得到基础值$ans[0]$。DFS的同时，计算出每棵子树的大小$size[i]$。然后从0出发再次DFS，设y是x的儿子，那么：$ans[y] = ans[x] + n - 2·size[y]$，利用该公式可以自顶向下递推得到每个$ans[i]$。\n**本质：**交换两个节点的父子关系，对应的只有一对节点的距离变化量，其余关系不改变。\n**子树大小如何计算？**所有儿子的子树大小之和 + 1；\n**DFS如何保证树每个节点只递归访问一次？**树结构，只要判断是否等于父节点即可。\n直径：树直径的概念，树中任意两点的最大距离被称为树的直径。以任意一点（例如0）开始遍历树：\n定义$f[i]$表示i的子树中最大深度，$g[i]$表示子树中的次大深度，显然如果直径过点i，那么它的最大长度为\n$$ diam = g[i] + f[i]\n$$\n我们dfs的过程枚举每个点i取最大就好了，至于算f和g的值….\n当计算$f[u]$和$g[u]$时，我们已经算好了$f[v]$和$g[v]$(v是u的儿子，并且这是个递归的过程，叶节点是终止条件)\n使用$f[v] + 1$来更新$f[u]$、$g[u]$即可。这样求得树1的直径为diam1，树2直径为diam2\n// 直径 void dfs(int u,int fa, int \u0026ans) { vis[u] = 1; for (const auto \u0026v : vec[u]) { if (vis[v]) { continue; } dfs(v, u, ans); if (f[v] + 1 \u003e= f[u]) { g[u] = f[u], f[u] = f[v] + 1; } else if (f[v] + 1 \u003e g[u]) { g[u] = f[v] + 1; } } ans = max(ans,f[u]+g[u]); } int res = 0; auto dfs = [\u0026](auto\u0026\u0026 dfs, int x, int fa) -\u003e int { int max_len = 0; for (auto y : g[x]) { if (y != fa) { int sub_len = dfs(dfs, y, x) + 1; res = max(res, max_len + sub_len); max_len = max(max_len, sub_len); } } return max_len; }; dfs(dfs, 0, -1); 图 有向无环图：拓扑排序\n基环树：link，dfs + 时间，拓扑排序删除非环部分 + dfs\n图的遍历思路：参考link 1、dfs +（访问过数组） 找连通块 或者环。 2、bfs 求权值为1的最短路径，，单源最短路即计算某节点到各节点的最短路径。 进一步，还可以参考847. 访问所有节点的最短路径，结合状态压缩思想，计算到全部节点的最短路径。扩展到超图的最短路径815. 公交路线，一条边可以连接超过两个节点的图。不断增加路径下的最短路径3243. 新增道路查询后的最短距离 I。甚至，3690. 拆分合并数组把状态抽象成图上的点，用 BFS 遍历这张图，计算从初始状态到目标状态的最短路长度。\n字典树 ref: 字典树 (Trie) - OI Wiki (oi-wiki.org)\n定义：一种空间换时间的树形数据结构，典型用于统计、排序、和保存大量字符串。与哈希表相比，字典树利用公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。\n字典树有3个基本性质：（1）根节点不包含字符，除根节点外每一个节点都只包含一个字符；从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；（3）每个节点的所有子节点包含的字符都不相同。\n字典序的数字：440. 字典序的第K小数字 - 力扣（LeetCode）\nclass Trie { struct Node{ int exist{-1}; // 确定字符串存在 int size{INT_MAX}; // 确定前缀字符串存在 Node *next[26]{}; }; Node* root{nullptr}; public: Trie():root(new Node()){} ~Trie(){} void insert(int idx, string\u0026 s) { // 插入字符串 Node* cur = root; // 前缀字符串最小长度 if(cur-\u003esize \u003e s.size()){ cur-\u003esize = s.size(); } // 公共前缀字符串最小长度和索引 //if(cur-\u003esize \u003e s.size()){ // cur-\u003esize = s.size(); // cur-\u003eexist = idx; //} for (int i = 0; i \u003c s.size(); ++i) { int c = s[i] - 'a'; if (cur-\u003enext[c] == nullptr) cur-\u003enext[c] = new Node(); // 为空则创建 cur = cur-\u003enext[c]; // 前缀字符串最小长度 if(cur-\u003esize \u003e s.size()){ cur-\u003esize = s.size(); } // 公共前缀字符串最小长度和索引 //if(cur-\u003esize \u003e s.size()){ // cur-\u003esize = s.size(); // cur-\u003eexist = idx; //} } // 字符串索引 cur-\u003eexist = idx; } int search(string\u0026 s) { // 查找字符串对应的索引 Node* cur = root; for (int i = 0; i \u003c s.size(); ++i) { int c = s[i] - 'a'; if (cur-\u003enext[c] == nullptr) return -1; cur = cur-\u003enext[c]; } return cur-\u003eexist; } int searchStartWith(string\u0026 s) { // 查找前缀字符串的最小长度 Node* cur = root; for (int i = 0; i \u003c s.size(); ++i) { int c = s[i] - 'a'; if (cur-\u003enext[c] == nullptr) return -1; cur = cur-\u003enext[c]; } return cur-\u003esize; } int searchComStartWith(string\u0026 s) { // 查找公共前缀字符串对应的索引 Node* cur = root; for (int i = 0; i \u003c s.size(); ++i) { int c = s[i] - 'a'; if (cur-\u003enext[c] == nullptr) break; cur = cur-\u003enext[c]; } return cur-\u003eexist; } }; int son[N][26], cnt[N], idx; // 0号点既是根节点，又是空节点 // son[][]存储树中每个节点的子节点 // cnt[]存储以每个节点结尾的单词数量 // 插入一个字符串 void insert(char *str){ int p = 0; for (int i = 0; str[i]; i++ ) { int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++idx; p = son[p][u]; } cnt[p]++; } // 查询字符串出现的次数 int query(char *str){ int p = 0; for (int i = 0; str[i]; i++){ int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } 并查集 ref: 并查集 - OI Wiki (oi-wiki.org)\n并查集是一种树形的数据结构，顾名思义，它用于处理一些元素的 合并 及 查询 问题。它支持两种操作：查找（Find），确定某个元素处于哪个子集；合并（Union），将两个子集合并成一个集合。注意，并查集不支持集合的分离，但是并查集在经过修改后可以支持集合中单个元素的删除操作（详见 UVA11987 Almost Union-Find）。使用动态开点线段树还可以实现可持久化并查集。\n操作：1、路径压缩，直接存储祖先节点。2、启发式合并，确保小合入大，优化合并操作复杂度。3、递归与非递归，非递归用while(true)搜索祖先节点\n时间复杂度：同时使用路径压缩查找和启发式合并之后，并查集的每个操作平均时间仅为$O(\\alpha(n))$，其中$\\alpha$为阿克曼函数的反函数，其增长极其缓慢，也就是说其单次操作的平均运行时间可以认为是一个很小的常数。$O(log* n)$ 的时间复杂度已经很快了，$O(log* n)$是比 $O(logn)$ 还要快，近似等于 $O(1)$，比 $O(1)$慢一点。\n空间复杂度：O(n)\n(1)朴素并查集 int fa[N+1]; // 初始化，假定节点编号是1~n for (int i = 1; i \u003c= n; i ++ ){ fa[i] = i; } int find(int x){ while (fa[x] != x) fa[x] = find(fa[x]); // 路径压缩 return fa[x]; } // 合并 fa[find(a)] = find(b); // 判断 bool IsConnect(int a, int b){ return find(a) == find(b); } (2)维护size的并查集： int fa[N+1], size[N+1]; // 初始化，假定节点编号是1~n for (int i = 1; i \u003c= n; i ++ ){ fa[i] = i; size[i] = 1; } // 搜索 int find(int x){ while (fa[x] != x) fa[x] = find(fa[x]); return fa[x]; } // 合并 if(size[a] \u003e size[b]) swap(a, b); size[find(b)] += size[find(a)]; // 启发式合并，从小到大 fa[find(a)] = find(b); (3)维护到祖宗节点距离的并查集： int fa[N+1], d[N+1]; // 初始化 for (int i = 1; i \u003c= n; i ++ ){ fa[i] = i; d[i] = 0; } // 搜索 int find(int x){ if (fa[x] != x) { int u = find(fa[x]); d[x] += d[fa[x]]; fa[x] = u; } return fa[x]; } // 合并，根据具体问题，初始化find(a)的偏移量 fa[find(a)] = find(b); d[find(a)] = distance; （4）带权并查集 + 离散化 // 初始化 unordered_map\u003cint,pair\u003cint,double\u003e\u003e fa; // 搜索 int Find(int x){ if(x != fa[x].first){ int t = fa[x].first; fa[x].first = Find(p[x].first); fa[x].second *= fa[t].second; return fa[x].first; } return x; } // 合并 void Union(int e1,int e2, double v){ int f1 = Find(e1); int f2 = Find(e2); if(f1 != f2){ fa[f2].first = f1; fa[f2].second = fa[e1].second * v / fa[e2].second; } } （5）区间并查集 int fa[N+1]; // 初始化 // 初始化 for (int i = 1; i \u003c= N; i ++ ){ fa[i] = i; } int find(int x){ // 非递归并查集 int re = x; while(fa[rt] != rt){ rt = fa[rt]; } while(fa[rt] != rt){ // 节点 int tmp = fa[x]; fa[x] = rt; x = tmp; } return rt; } // 合并 int cnt = n-1; // 并查集连通块个数 int fr = find(R); for(int i=find(L); i \u003c= R; i = find(i+1)){ fa[i] = fr; cnt--; } （6）二维并查集 子序列 1、第一反应，排序\n2、子序列贡献法\n以i作为端点，往左作为最大值，数量为2^{i}。\n以i作为端点，往右作为最小值，数量为2^{n-1-i}。\n3、子序列DP\n相邻无关：0-1 背包\n相邻相关：最长递增子序列\n选或不选\n差值绝对值的最小值 ==》相邻相关 选或不选 ​ 递增子序列个数 dfs(i,pre) 不选dfs(i-1,pre) 选dfs(i-1,nums[i]) ​ i是当前下标 j是还需要选多少个数 pre·是上一个选的数 dfs(i,j,pre) ​ i是当前下标 j是还需要选多少个数 pre·是上一个选的数 min_diff 目前选的数的能量 dfs(i,j,pre,min_diff) 思路：\n1. 不选dfs(i-1, j, pre, min_diff)\n2. 选dfs(i-1, j-1, nums[i], min(min_diff, pre-nums[i]))\n3. j=0 返回min_diff\n4. j \u003e i+1, 即使剩下的数全部选，也不足 j 个，返回0\n5. 递归入口，dfs(n-1, k, INT_MAX, INT_MA)\n字符串的子序列个数：具体来说，在遍历s的过程中，把s[i]加到前i-1个字符组成的不同子序列的末尾，同时把s[i]单独作为一个子序列，即得到了前i个字符以s[i]结尾的不同子序列的个数。遍历结束后把以a,b,…,z结尾的不同子序列的个数相加，就得到了答案。\n有序子序列\n2386. 找出数组的第 K 大和 - 力扣（LeetCode）\n如何不重不漏地生成 nums的所有子序列？\n以有序非负数组 nums=[1,2,3] 为例，有2^3=8个子序列，生成的方法如下：\n从空子序列 [] 开始。\n在 [] 末尾添加 1 得到 [1]。\n在 [1]末尾添加 2 得到 [1,2]。也可以把末尾的 1 替换成 2 得到 [2]。\n在 [2]末尾添加 3 得到[2,3]。也可以把末尾的 2 替换成 3 得到 [3]。\n在 [1,2] 末尾添加 3 得到 [1,2,3]。也可以把末尾的 2 替换成 3 得到[1,3]。\n上述过程结合最小堆，就可以按照从小到大的顺序生成所有子序列了（堆中维护子序列的和以及下一个要添加/替换的元素下标）。取生成的第 kkk 个子序列的和，作为 sum要减去的数。\n答疑 问：为什么结合最小堆，就一定是按元素和从小到大的顺序生成的？有没有可能先生成一个大的，再生成一个小的？\n答：把子序列和它通过添加/替换生成的子序列之间连一条有向边，我们可以得到一棵以 [] 为根的有向树。把边权定义成相邻节点的子序列元素和的差，由于nums是有序的且没有负数，所以树是没有负数边权的。那么上述算法其实就是在这棵树上跑 Dijkstra 算法。把元素和当作海拔高度，算法执行过程就好比不断上涨的水位，我们会按照海拔高度从低到高淹没节点，所以出堆的元素和是非降的。\nlong sum = 0L; for (int \u0026x : nums) { if (x \u003e= 0) { sum += x; } else { x = -x; } } ​ ​ ranges::sort(nums); ​ priority_queue\u003cpair\u003clong, int\u003e, vector\u003cpair\u003clong, int\u003e\u003e, greater\u003c\u003e\u003e pq; pq.emplace(0, 0); // 空子序列 while (--k) { auto [s, i] = pq.top(); pq.pop(); if (i \u003c nums.size()) { // 在子序列的末尾添加 nums[i] pq.emplace(s + nums[i], i + 1); // 下一个添加/替换的元素下标为 i+1 if (i) { // 替换子序列的末尾元素为 nums[i] pq.emplace(s + nums[i] - nums[i - 1], i + 1); } } return sum - pq.top().first; } 子数组/子串 思路：\n1、以i作为右端点的子数组，最暴力思路。OR 和 AND题型，3097. 或值至少为 K 的最短子数组 II - 力扣（LeetCode）\n2、将所有子串按照其末尾字符的下标分组。考虑两组相邻的子串：以 s[i−1] 结尾的子串、以 s[i] 结尾的子串。以 s[i] 结尾的子串，可以看成是以 s[i−1] 结尾的子串，在末尾添加上 s[i] 组成。最后分类讨论，之前没有遇到过/最前遇到过，推理出公式。上面这一串提示是思考子串统计类问题的通用技巧之一。 2262. 字符串的总引力828. 统计子串中的唯一字符\n树状数组 树状数组（Binary Indexed Tree），又称 Fenwick 树，将线性结构转化成树状结构，从而二进制搜索进行跳跃式扫描，一种有效的区间修改和区间查询O(log n) 的数据结构。\n场景：区间和，区间个数（值域），区间异或，区间最大/最小值\n建议：link，在考场上，面对功能极度全面的线段树O（Ologn），以及代码量少的树状数组O（nlognlogn），加以权衡。\n问题点1：如何定义树状数组的大小。\n答：与原数组一样大小，节省空间（开两倍的原数组就可，线段树需要开四倍原数组）；\n问题点2：如何进位移动。\n答：lowbit，x \u0026 (-x)，把k的二进制的高位1全部清空；注意：无法处理0的情况，因为它的结果也是0，那么最终就是一个死循环。\ntemplate\u003cclass T\u003e class Fenwick{ pulic: vector\u003cT\u003e tree; public: Fenwick(int n):tree(n){} void add(int x, T v){ for(; x \u003c tree.size(); x += x \u0026 (-x)) tree[x] += v； } T query(int x){ T v = 0; for(; x \u003e 0; x -= x \u0026 (-x)) v += tree[x]; return v; } }; // Fenwick s(n+1); // n = 1e5 /* 场景一：单点修改，单点/区间查询 */ Fenwick\u003clong long\u003e s(n+1); // 构造 s.add(x, v); // 单点[1, x]修改v long long sum = s.query(x); // 单点[1, x]查询sum long long sum = s.query(r) - s.query(l-1); // 区间[l, r]查询 /* 场景二：区间修改，区间查询 */ Fenwick\u003clong long\u003e s(n+1), sx(n+1); // 构造 // 区间[l, r]修改v s.add(l, v); s.add(r+1, -v); sx.add(l, l*v); sx.add(r+1, -(r+1)*v); long long sum = (r+1) * s.sum(r)- l*s.sum(l-1) - (sx.sum(r) - sx.sum(l-1)); // 区间[l, r]查询sum /* 场景三、区间范围和 */ // 1、先前缀和，再离散化，需要增加presum - low 和 presum -high。 // 2、区间查询从[low, high] 变为[presum - high, presum - low]。 /* 场景四、区间数，问题：区间内小于/大于val的个数。方案：单点修改，区间查询 */ int n = 1e5; Fenwick\u003cint\u003e s(n+1); s.add(x, 1); // 单点修改 s.query(x); // 区间查询 小于等于x的数量 s.query(n) - s.query(x); // 区间查询 大于x的数量 /* 场景五、离散化，数组排序，哈希存储*/ int n = nums.size(); vector\u003cint\u003e sorted(nums.begin(), nums.end()); sort(sorted.begin(), sorted.end()); unordered_map\u003cint, int\u003e mp; for(int i=0, pos = 1; i \u003c n; ++i){ if(mp.count(sorted[i])) continue; mp[sorted[i]] = pos++; } Fenwick\u003cint\u003e s(n+1); // 构造 s.add(mp[x], 1); // 先映射mp[x]，再修改 /* 场景六：区间异或 */ /* 场景七：区间最大值和最小值，改为区间和 */ void add(int p,int x){ //添加一个数（不能修改） for(;p\u003c=n;p+=p\u0026(-p)){ c[p].mx=max(c[p].mx,x);//维护区间的最大以及最小 c[p].mn=min(c[p].mn,x); } } bool sum(int l,int r){ int mx=-0x7f7f7f7f,mn=0x7f7f7f7f; while(l\u003c=r){ for(;r-(r\u0026(-r))\u003e=l;r-=r\u0026(-r))//标配 { mx=max(c[r].mx,mx); mn=min(c[r].mn,mn); } mx=max(mx,a[r]); mn=min(mn,a[r]); r--;//不是所有区间都已处理，所以会多次维护 } if(abs(mx-mn)\u003c=ci) return true; return false; } 前缀和 定义：对于数组 nums，定义它的前缀和 $s[0] = 0$, $s[i+1] = \\sum_{j=0}^{i} nums[j]$。例如 $nums[i] = [1, 2, -1, -2]$，对应的前缀和数组为$s = [0, 1, 3, 2, 4]$。通过前缀和，子数组的元素和转换成两个前缀和的差，即\n$$ \\sum_{j=left}^{right} nums[j] = \\sum_{j=0}^{right} nums[j] - \\sum_{j=0}^{left-1}nums[j] = s[right+1] - s[left] $$\n例如 nums的子数组$[2,-1,2]$的和就可以为是$s[4]-s[1]=4-1=3$。\n注：为方便计算，常用左开右闭区间$[left,right)$来表示子数组，此时子数组的和为$s[right]-s[left]$，子数组的长度为right-left。\n注2：$s[0] = 0$ 表示的是一个空数组的元素和。为什么要额外定义它？想一想，如果要计算的子数组恰好是一个前缀（从$nums[0]$开始），你要用$s[right]$ 减去谁呢？通过定义$s[0]=0$，任意子数组（包括前缀）都可以表示为两个前缀和的差。\n二维/多维前缀和：多维前缀和的普通求解方法几乎都是基于容斥原理；前缀和公式：$(i,j)$表示当前位置\n$$ sum_{ij} = sum_{i-1j} + sum_{ij-1} - sum_{i-1j-1} + a_{i}{j} $$\n区间和公式：$(x1,y1)$到$(x2,y2)$\n$$ sum_{x2y2} - sum_{x1-1y2} - sum_{x2y1-1} + sum_{x1-1y1-1} $$\nfor(int i=0; i \u003c m; ++i){ for(int j=0; j \u003c n; ++j){ sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + matrix[i][j]; } } int sumRegion(int r1, int c1, int r2, int c2) { return sum[r2 + 1][c2 + 1] - sum[r2 + 1][c1] - sum[r1][c2 + 1] + sum[r1][c1]; } 基于 DP 计算高维前缀和：前缀和 \u0026 差分 - OI Wiki (oi-wiki.org)，基于容斥原理来计算高维前缀和的方法，其优点在于形式较为简单，无需特别记忆，但当维数升高时，其复杂度较高。\n设高维空间 $U$ 共有 $D$x 维，需要对 $f[\\cdot]$ 求高维前缀和 $\\text{sum}[\\cdot]$。令$\\text{sum}[i][\\text{state}]$表示同 $\\text{state}$ 后 D - i 维相同的所有点对于$ \\text{state}$ 点高维前缀和的贡献。由定义可知 $\\text{sum}[0][\\text{state}] = f[\\text{state}]$，以及 $\\text{sum}[\\text{state}] = \\text{sum}[D][\\text{state}]$。\n其递推关系为$\\text{sum}[i][\\text{state}] = \\text{sum}[i - 1][\\text{state}] + \\text{sum}[i][\\text{state}’]$，其中$\\text{state}’$ 为第 i 维恰好比 $\\text{state}$ 少 1 的点。该方法的复杂度为 $O(D \\times |U|)$，其中 $|U|$ 为高维空间 $U$ 的大小。\n一种实现的伪代码如下：\nfor state sum[state] = f[state]; for(i = 0;i \u003c= D;i += 1) for 以字典序从小到大枚举 state sum[state] += sum[state']; 树上前缀和：设 $\\textit{sum}_i$ 表示结点 i 到根节点的权值总和。然后：\n若是点权，x,y 路径上的和为 $\\textit{sum}x + \\textit{sum}y - \\textit{sum}\\textit{lca} - \\textit{sum}{\\textit{fa}_\\textit{lca}}$。 若是边权，x,y 路径上的和为$\\textit{sum}_x + \\textit{sum}y - 2\\cdot\\textit{sum}{lca}$。 LCA 的求法参见 最近公共祖先。 #2491. 「BJOI2018」求和 - 题目 - LibreOJ (loj.ac) 差分 原理：前缀和 \u0026 差分 - OI Wiki (oi-wiki.org)，差分是一种和前缀和相对的策略，可以当做是求和的逆运算。\n当我们希望对原数组的某一个区间[l,r]施加一个增量inc时，差分数组d对应的变化是：d[l]增加inc，d[r+1]减少inc，并且这种操作是可以叠加的。\n作用：它可以维护多次对序列的一个区间加上一个数，并在最后询问某一位的数或是多次询问某一位的数。注意修改操作一定要在查询操作之前。\n一维差分——模板题 AcWing 797. 差分：\n给区间[l, r]中的每个数加上c： B[l] += c B[r + 1] -= c 二维差分——模板题 AcWing 798. 差分矩阵：\n给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c S[x2 + 1, y1] -= c S[x1, y2 + 1] -= c S[x2 + 1, y2 + 1] += c 离散化差分：由于1e9的区间长度，需要进行离散化，思路是将出现的点升序排序并去重。对于每个点都映射为其排序后的下标。（用map实现）。\n2251. 花期内花的数目 - 力扣（LeetCode）\nclass Solution { public: vector\u003cint\u003e fullBloomFlowers(vector\u003cvector\u003cint\u003e\u003e \u0026flowers, vector\u003cint\u003e \u0026persons) { map\u003cint, int\u003e diff; for (auto \u0026f : flowers) { ++diff[f[0]]; --diff[f[1] + 1]; } int n = persons.size(); vector\u003cint\u003e id(n); iota(id.begin(), id.end(), 0); sort(id.begin(), id.end(), [\u0026](int i, int j) { return persons[i] \u003c persons[j]; }); vector\u003cint\u003e ans(n); auto it = diff.begin(); int sum = 0; for (int i : id) { while (it != diff.end() \u0026\u0026 it-\u003efirst \u003c= persons[i]) sum += it++-\u003esecond; // 累加变化量 ans[i] = sum; } return ans; } }; 线段树 线段树 - OI Wiki (oi-wiki.org)\n715. Range 模块 - 力扣（LeetCode）\n前缀和、差分和线段树 都是工具，当我们遇到某些特定情况时才会使用：\n查询区间和 修改区间（比如每个数 +x) 前缀和 O(1) O(N) 差分 O(N) O(1) 线段树 O(logN) O(logN) 当我们需要较多的区间查询时，我们考虑前缀和； 当我们需要较多的区间修改时，我们考虑差分； 当我们两点都需要时，上板子（线段树）； 线段树可以在$O(logN)$的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值)等操作。\n区间求和：\nclass SegMentTree { public: // static cont inst N=1e5; // struct Node { // int l, r, v, m; // } t[N\u003e\u003e1 + 1]; struct Node { int l, r, v, m; Node *nl, *nr; Node(int l, int r) : l(l), r(r), v(0), m(0), nl(nullptr), nr(nullptr) {} } *root; SegMentTree() { root = new Node(0, (int)(1e9)); } void create(Node *no) { int mid = (no-\u003el + no-\u003er) / 2; if (no-\u003enl == nullptr) { no-\u003enl = new Node(no-\u003el, mid); } if (no-\u003enr == nullptr) { no-\u003enr = new Node(mid + 1, no-\u003er); } } void pushdown(Node *no) { if (!no-\u003em) { return; } no-\u003enl-\u003ev += no-\u003em; no-\u003enr-\u003ev += no-\u003em; no-\u003enl-\u003em += no-\u003em; no-\u003enr-\u003em += no-\u003em; no-\u003em = 0; } void pushup(Node *no) { no-\u003ev = max(no-\u003enl-\u003ev, no-\u003enr-\u003ev); } void build(Node *no, int l, int r) { if (l == r) { no-\u003ev = 0; // a[i] return; } create(no); // 动态开点 int mid = (l + r) / 2; build(no-\u003enl, l, mid); build(no-\u003enr, mid + 1, r); pushup(no); // 注意，创建时不需要下沉，直接上浮 } void update(Node *no, int l, int r, int v) { // 1. 当前更新区间[l, r] 不在目标区间; if (no-\u003el \u003e r || no-\u003er \u003c l) { return; } // 2. 当前更新区间[l, r] 全部在目标区间； if (no-\u003el \u003e= l \u0026\u0026 no-\u003er \u003c= r) { no-\u003ev += v; no-\u003em += v; return; } // 3. 当前更新区间[l, r] 部分在目标区间 create(no); // 动态开点 pushdown(no); // 下沉 int mid = (no-\u003el + no-\u003er) / 2; if(l \u003c= mid){ update(no-\u003enl, l, r, v); } if(r \u003e mid){ update(no-\u003enr, l, r, v); } pushup(no); // 上浮 } int query(Node *no, int l, int r) { // 1. 当前搜索区间[l, r] 不在目标区间; if (no-\u003el \u003e r || no-\u003er \u003c l) { return 0; } // 2. 当前搜索区间[l, r] 全部在目标区间； if (no-\u003el \u003e= l \u0026\u0026 no-\u003er \u003c= r) { return no-\u003ev; } // 3. 当前搜索区间[l, r] 部分在目标区间 create(no); // 动态开点 pushdown(no); // 下沉 int mid = (no-\u003el + no-\u003er) / 2; int ret = 0; if (l \u003c= mid) { ret = max(ret, query(no-\u003enl, l, r)); } if (mid \u003c r) { ret = max(ret, query(no-\u003enr, l, r)); } return ret; } void update(int l, int r, int v) { update(root, l, r, v); } int query(int l, int r) { return query(root, l, r); } };class SegMentTree { public: // static cont inst N=1e5; // struct Node { // int l, r, v, m; // } t[N\u003e\u003e1 + 1]; struct Node { int l, r, v, m; Node *nl, *nr; Node(int l, int r) : l(l), r(r), v(0), m(0), nl(nullptr), nr(nullptr) {} } *root; SegMentTree() { root = new Node(0, (int)(1e9)); } void create(Node *no) { int mid = (no-\u003el + no-\u003er) / 2; if (no-\u003enl == nullptr) { no-\u003enl = new Node(no-\u003el, mid); } if (no-\u003enr == nullptr) { no-\u003enr = new Node(mid + 1, no-\u003er); } } void pushdown(Node *no) { if (!no-\u003em) { return; } no-\u003enl-\u003ev += no-\u003em; no-\u003enr-\u003ev += no-\u003em; no-\u003enl-\u003em += no-\u003em; no-\u003enr-\u003em += no-\u003em; no-\u003em = 0; } void pushup(Node *no) { no-\u003ev = max(no-\u003enl-\u003ev, no-\u003enr-\u003ev); } void build(Node *no, int l, int r) { if (l == r) { no-\u003ev = 0; // a[i] return; } create(no); // 动态开点 int mid = (l + r) / 2; build(no-\u003enl, l, mid); build(no-\u003enr, mid + 1, r); pushup(no); // 注意，创建时不需要下沉，直接上浮 } void update(Node *no, int l, int r, int v) { // 1. 当前更新区间[l, r] 不在目标区间; if (no-\u003el \u003e r || no-\u003er \u003c l) { return; } // 2. 当前更新区间[l, r] 全部在目标区间； if (no-\u003el \u003e= l \u0026\u0026 no-\u003er \u003c= r) { no-\u003ev += v; no-\u003em += v; return; } // 3. 当前更新区间[l, r] 部分在目标区间 create(no); // 动态开点 pushdown(no); // 下沉 int mid = (no-\u003el + no-\u003er) / 2; if(l \u003c= mid){ update(no-\u003enl, l, r, v); } if(r \u003e mid){ update(no-\u003enr, l, r, v); } pushup(no); // 上浮 } int query(Node *no, int l, int r) { // 1. 当前搜索区间[l, r] 不在目标区间; if (no-\u003el \u003e r || no-\u003er \u003c l) { return 0; } // 2. 当前搜索区间[l, r] 全部在目标区间； if (no-\u003el \u003e= l \u0026\u0026 no-\u003er \u003c= r) { return no-\u003ev; } // 3. 当前搜索区间[l, r] 部分在目标区间 create(no); // 动态开点 pushdown(no); // 下沉 int mid = (no-\u003el + no-\u003er) / 2; int ret = 0; if (l \u003c= mid) { ret = max(ret, query(no-\u003enl, l, r)); } if (mid \u003c r) { ret = max(ret, query(no-\u003enr, l, r)); } return ret; } void update(int l, int r, int v) { update(root, l, r, v); } int query(int l, int r) { return query(root, l, r); } }; 算法学习笔记(14): 线段树 - 知乎 (zhihu.com)\n区间取反：\nstatic constexpr int MX = 4e5 + 1; int cnt[MX]; bool flip[MX]; // 维护区间 1 的个数 void maintain(int o) { cnt[o] = cnt[o * 2] + cnt[o * 2 + 1]; } // 执行区间反转 void do_(int o, int l, int r) { cnt[o] = r - l + 1 - cnt1[o]; flip[o] = !flip[o]; } // 初始化线段树 o,l,r=1,1,n void build(vector\u003cint\u003e \u0026a, int o, int l, int r) { if (l == r) { cnt[o] = a[l - 1]; return; } int m = (l + r) / 2; build(a, o * 2, l, m); build(a, o * 2 + 1, m + 1, r); maintain(o); } // 反转区间 [L,R] o,l,r=1,1,n void update(int o, int l, int r, int L, int R) { if (L \u003c= l \u0026\u0026 r \u003c= R) { do_(o, l, r); return; } int m = (l + r) / 2; if (flip[o]) { do_(o * 2, l, m); do_(o * 2 + 1, m + 1, r); flip[o] = false; } if (m \u003e= L) update(o * 2, l, m, L, R); if (m \u003c R) update(o * 2 + 1, m + 1, r, L, R); maintain(o); } Lazy 线段树：\n字符串 定义：由零个或多个字符组成的有限序列。一般记为s=a1a2a3…an，在编程语言中表示文本的数据类型。\n字符串连接：考虑可变性，C++字符串通过重载+运算符可改变，而python和java中无法改变，需要重新创建内存空间，再复制旧字符串中的内容到新字符串，多$O(n)$时间复杂度。如何解决方案该问题呢？答：转换成字符数组或其他数据结构。\n字符串比较：c++和python中可以用==来比较字符串，java中无法用==比较字符串，实际上去比较这个两个对象是否是同一个对象。c++中可以用s1.compare(s2)。\n字符串切片：python具有切片操作str[start_pos: start_pos+len],而c++中可以用str.substr(start_pos， len)。\n字符串遍历：（1）在C语言中，把一个字符串存入一个数组时，也把结束符 ‘\\0’存入数组，并以此作为该字符串是否结束的标志。（2）在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用’\\0’来判断是否结束。其实，在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。所以想处理字符串，我们还是会定义一个string类型。\n字符串反转：（1）双指针：左指针指向头部，右指针指向尾部；（2）交换字符：临时变量，位运算，swap。\nvoid reverseString(vector\u003cchar\u003e\u0026 s) { for (int i = 0， j = s.size() - 1; i \u003c s.size()/2; i++，j--) { swap(s[i]，s[j]); } } 字符串分割：\nstringstream ss(sentence, ' '); string w; while (ss \u003e\u003e w) { std::cout \u003c\u003c w \u003c\u003c \" \"; } std::cout \u003c\u003c endl; 字符串精度：\nstringstream s; s \u003c\u003c fixed \u003c\u003c setprecision(2) \u003c\u003c '$' \u003c\u003c stoll(w.substr(1)) * d; ans += s.str(); 字符串回文：一个正读和反读都一样的字符串。\n1、回文字符串判断：1、反转比较；2、双指针。\n2、若可以冗余删除一个或多个字符，递归思路。\n3、最长回文字串：中心扩展算法（递归判断单字符或双字符的情况），动规。\n4、回文字符串生成：仅考虑一半即可，反转相加得到回文字符串；\n字符串子序列：从一个字符串中删除一些元素后，不改变剩下元素的顺序得到的字符串。\n1、排序：一看到子序列，就想到排序。\n2、子序列判断：采用双指针法，若字符相同，则指针往前一步，当t字符串遍历结束，查看s字符串是否达到字符串的最后一个位置，若是，返回true，否则，返回false。\n3、子序列输出：回溯算法。\n字符串子串：连续字符串。\n1、滑动窗口：\n2、前缀和 + 哈希表：\n前缀和：为方便计算，常用左闭右开区间$[\\textit{left},\\textit{right})$ 来表示子数组，此时子数组的和为 $s[right]−s[left]$，子数组的长度为 right−left。\n匹配：字符串匹配（String Matching）是计算机科学中的一个基础问题，它涉及到在一个主字符串（或称为文本）中查找一个或多个子字符串（或称为模式）的出现位置。字符串匹配算法在计算机编程、文本编辑器、搜索引擎、生物信息学等许多领域都有广泛的应用。简单来说，字符串s里查找模式串t！\n1、KMP：如何更好地理解和掌握 KMP 算法? - 知乎 (zhihu.com)，Knuth，Morris和Pratt三位学者发明并以首字母命名为KMP算法，其主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。 这是一种改进的字符串匹配算法，它利用已经匹配的信息来避免不必要的比较。KMP算法的核心是预处理子字符串，生成一个称为“部分匹配表”（Partial Match Table）的数据结构，用于在匹配失败时确定下一个比较的位置。KMP算法的时间复杂度是O(n+m)。\n步骤一：计算最长公共前后缀next[i]，用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。注意，前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串，后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。而公共前后缀实质上前缀相当于字串匹配的相同字串，后缀表示原串中的相同字符，因此可以根据这个来回退字串，继续匹配。如：abcabcabf和abcabf，当匹配到第5个字符时候，c和f不相等，子串应该回退到第2个字符位置继续匹配。\n对于abcabf，$next[6]={0，0，0，1，2，0}$ 即a时，最长前后缀长度是0；即ab时，最长前后缀长度是0；即abc时，最长前后缀长度是0；即abca时，最长前后缀长度是1；即abcab时，最长前后缀长度是2；前2个字母后最后两个字母相等；即abcabf时，没有最长前后缀，长度是0；\nint m = t.size(); vector\u003cint\u003e next(m); // 公共前后缀 int cnt = 0; for(int i = 1; i \u003c m; i++) { // 注意i从1开始，第一个字符没有公共前后缀 while (cnt \u0026\u0026 t[cnt] != t[i]) { // 直到前后缀不相同 cnt = next[cnt-1]; // 向前回退 } if (t[cnt] == t[i]) { // 字符匹配，具有相同的前后缀 cnt++; } next[i] = cnt; // 更新公共前后缀 } 步骤二：在字符串s里找是否出现过模式串t。\nint ans = 0; // 统计匹配次数 cnt = 0; for (int i = 0; i \u003c s.size(); i++) { while(cnt \u0026\u0026 t[cnt] != s[i]) { // 直到前后缀不相同 cnt = next[cnt - 1]; // 向前回退 } if (t[cnt] == s[i]) { // 字符匹配，具有相同的前后缀 cnt++; } if (cnt == m) { // 字符串s里匹配上模式串t ans++; cnt = next[cnt-1]; } } 时间复杂度：n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)。\n2、哈希匹配\nRabin-Karp算法：这是一种基于哈希的字符串匹配算法，它利用哈希函数将字符串转换为数值，并通过比较这些数值来快速判断字符串是否匹配。Rabin-Karp算法的时间复杂度是O(n+m)，但它需要额外的空间来存储哈希值。\n字符串哈希：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低，一个小技巧是取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果。\ntypedef unsigned long long ULL; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64 struct Hash{ const int mod1=100663319,mod2=201326611; const LL P1=131,P2=13331; vector\u003cLL\u003e p1,p2,h1,h2,t1,t2; void init(string s){ int n=(int)s.size()-1; p1.assign(n+1,0);p2.assign(n+1,0); h1.assign(n+1,0);h2.assign(n+1,0); t1.assign(n+2,0);t2.assign(n+2,0); p1[0]=p2[0]=1; for(int i=1;i\u003c=n;i++){ p1[i]=p1[i-1]*P1%mod1; p2[i]=p2[i-1]*P2%mod2; h1[i]=(h1[i-1]*P1%mod1+s[i]-'0'+1)%mod1; h2[i]=(h2[i-1]*P2%mod2+s[i]-'0'+1)%mod2; } for(int i=n;i\u003e=1;i--){ t1[i]=(t1[i+1]*P1%mod1+s[i]-'0'+1)%mod1; t2[i]=(t2[i+1]*P2%mod2+s[i]-'0'+1)%mod2; } } int getHash1(int l,int r){ return (h1[r]-(h1[l-1]*p1[r-l+1])%mod1+mod1)%mod1; } int getHash2(int l,int r){ return (h2[r]-(h2[l-1]*p2[r-l+1])%mod2+mod2)%mod2; } int getRevHash1(int l,int r){ return (t1[l]-(t1[r+1]*p1[r-l+1])%mod1+mod1)%mod1; } int getRevHash2(int l,int r){ return (t2[l]-(t2[r+1]*p2[r-l+1])%mod2+mod2)%mod2; } }Hash; STL vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 pair\u003cint, int\u003e first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大根堆 优先级队列是一个拥有权值的queue，其内部元素按照元素的权值排列。权值较高者排在最前优先出队。其中缺省情况下系统是通过一个max-heap以堆实现完成排序特性，表现为一个以vector表现的完全二叉树。 操作：插入元素O(logn)、查询最大值O(1)、删除最大值O(1)； 底层：最大堆或最小堆； size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e q; stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 bitset\u003c10000\u003e s; ~, \u0026, |, ^ \u003e\u003e, \u003c\u003c ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 算法 排序算法 双指针 双指针法（快慢指针法）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作\n模板\n// 双指针操作 for(int i = 0, j; i \u003c n; i = j) { j = i; while(j \u003c n \u0026\u0026 a[i] == a[j]) j ++; //a[i] ~ a[j] 都相等 } 滑动窗口 ref：分享丨【题单】滑动窗口（定长/不定长/多指针） - 力扣（LeetCode）\n原理：以i作为右端点，根据条件移动左端点，最后通过左右端点位置计算长度或者数量等。\n定长：套路（右进左出，计算两个操作上区间变化）。\n不定长：求最长/最大子数组、求最短/最小子数组、以及求子数组个数\n2.3 恰好性滑动窗口：转换成两个至少型滑动窗口，如3306. 元音辅音字符串计数 II。 多指针：\n小技巧1：原地去重\nranges::sort(nums); nums.erase(unique(nums.begin(), nums.end()), nums.end()); // 原地去重 2009. 使数组连续的最少操作数 - 力扣（LeetCode）\n思考1：双指针与滑动窗口区别？双指针与滑动窗口方法总结 - 悬浮海 - CSDN：将计算过程仅与两端点相关的称为「双指针」，将计算过程与两端点表示的区间相关的称为「滑动窗口」。\n二分查找 概念：二分 - OI Wiki (oi-wiki.org)，用来在一个有序数组中查找某一元素的算法，比较中间元素与目标元素的匹配情况，从而减少一半区间；\n时间复杂度：最优$O(1)$，平均和最坏$O(logn)$；\n空间复杂度：迭代$O(1)$，递归$O(logn)$\n关键点：最大值最小化和最小值最大化，link；\n模板\n1、区间$[l, r]$被划分成$[l, mid]$和$[mid + 1, r]$时候\nbool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间可以考虑：left + （right- left）/2 = 0（向下取整） int bsearch(int l, int r) { int ret = -1; // 辅助点 while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (check(mid)){ r = mid; ret = mid; } else{ l = mid + 1; } } return l; } 2、区间$[l, r]$被划分成$[l, mid - 1]$和$[mid, r]$时\nbool check(int x) {/* ... */} // 检查x是否满足某种性质 //区间可以考虑：（left + right + 1）/2 = 1 int bsearch(int l, int r) { int ret = -1; // 辅助点 while (l \u003c r) { int mid = l + r + 1 \u003e\u003e 1; if (check(mid)){ l = mid; ret = mid; } else{ r = mid - 1; } } return l; } 注意：浮点数，r - l \u003e 1e-6；\n注意：对于n是有符号数的情况，当你可以保证 $n\\ge 0$时，n \u003e\u003e 1 比 n / 2 指令数更少。\nAPI\nstd::lower_bound：查找首个不小于给定值的元素的函数；\nstd::upper_bound：查找首个大于给定值的元素的函数；\n三分查找 三分法与二分法的基本思想类似，但每次操作需在当前区间 $[l, r]$内任取两点 $[lmid,rmid]$。如果 $f(lmid)",
  "wordCount" : "5082",
  "inLanguage": "zh",
  "image": "https://yangly0.github.io/images/avatar.webp","datePublished": "2024-10-26T09:57:32Z",
  "dateModified": "2024-10-26T09:57:32Z",
  "author":{
    "@type": "Person",
    "name": "Yangly"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://yangly0.github.io/posts/20241026095732/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "所见所思",
    "logo": {
      "@type": "ImageObject",
      "url": "https://yangly0.github.io/images/avatar.webp"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://yangly0.github.io/" accesskey="h" title="所见所思 (Alt + H)">所见所思</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://yangly0.github.io/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://yangly0.github.io/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://yangly0.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://yangly0.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      数据结构与算法 个人篇
    </h1>
    <div class="post-meta"><span title='2024-10-26 09:57:32 +0000 UTC'>2024年10月26日</span>&nbsp;·&nbsp;<span>Yangly</span>

</div>
  </header> 
  <div class="post-content"><p>摘要：本文是个人日常对数据结构与算法的学习内容。</p>
<h2 id="模板">模板<a hidden class="anchor" aria-hidden="true" href="#模板">#</a></h2>
<p>参考<a href="https://www.acwing.com/activity/content/11/">AcWing</a>和<a href="https://oi-wiki.org/">OI Wiki</a>，几乎所有数据结构和算法都有相应模板。</p>
<h2 id="输入输出">输入输出<a hidden class="anchor" aria-hidden="true" href="#输入输出">#</a></h2>
<p>ref：<a href="https://blog.csdn.net/jeffscott/article/details/107968919">OJ的自我修养：C++输入输出总结_c++ oj的输入输出-CSDN博客</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp"> </span><span class="c1">//全部头文件，必备
</span></span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> <span class="c1">// 命名空间
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// c语言
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EOF</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span> <span class="c1">// 注意点，引用
</span></span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// c++语言
</span></span></span><span class="line"><span class="cl"><span class="cm">/*&gt;&gt; 数值带定长  */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">){</span>  <span class="c1">// 忽略空格，回车，Tab，遇到EOF会跳出循环
</span></span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*&gt;&gt; 数值带不定长  */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">getchar</span><span class="p">()</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">){</span>  <span class="c1">// 遇到回车结束
</span></span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*&gt;&gt; 字符串  */</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span> <span class="c1">// cin遇到空格结束读取
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*&gt;&gt; 字符串带空格  */</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// getline函数可以获取包含空格的字符，以回车键结束
</span></span></span><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">str</span><span class="p">)){</span> <span class="c1">// 遇到EOF或者CTRL+Z退出
</span></span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*&gt;&gt; 字符串带逗号  */</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">strs</span><span class="p">,</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">strs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">stringstream</span> <span class="nf">input</span><span class="p">(</span><span class="n">strs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// python 版本
</span></span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="nl">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">input</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">_</span> <span class="n">in</span> <span class="n">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">lis</span> <span class="o">=</span> <span class="n">list</span><span class="p">(</span><span class="n">map</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">            <span class="n">print</span><span class="p">(</span><span class="n">sum</span><span class="p">(</span><span class="n">lis</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="nl">except</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span>
</span></span></code></pre></div><h2 id="数据结构">数据结构<a hidden class="anchor" aria-hidden="true" href="#数据结构">#</a></h2>
<h3 id="有序数组">有序数组<a hidden class="anchor" aria-hidden="true" href="#有序数组">#</a></h3>
<p>区间范围值$[l,r]$：<code>upper_bounder(…,…,r) - lower_bounder(…,…,l)</code></p>
<h3 id="链表">链表<a hidden class="anchor" aria-hidden="true" href="#链表">#</a></h3>
<p>定义：链表是一种<code>线性</code>数据结构。链表中的每个元素实际上是一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起。</p>
<p>单链表：1、与数组的区别，$O(N)$查询，$O(1)$插入和删除；2、注意的是头节点处理；3、经典问题：反转链表、移除链表元素、奇偶链表、回文链表（快慢双指针）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">ListNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">ListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="nb">NULL</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">ne</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">idx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">head</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 在链表头插入一个数a
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">e</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">ne</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">idx</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 将头结点删除，需要保证头结点存在
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">remove</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">head</span> <span class="o">=</span> <span class="n">ne</span><span class="p">[</span><span class="n">head</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>双链表：1、与数组的区别，最坏情况下$O(N)$查询，$O(1)$插入和删除；2、注意的是头节点和尾节点处理；3、经典题型：扁平化多级双向链表、复制带随机指针的链表、旋转链表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DoublyListNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DoublyListNode</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DoublyListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">prev</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">e</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">idx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//0是左端点，1是右端点
</span></span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 在节点a的右边插入一个数x
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">e</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">a</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">a</span><span class="p">]]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">++</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 删除节点a
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">a</span><span class="p">]]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">a</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="n">a</span><span class="p">]]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">a</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="哈希表">哈希表<a hidden class="anchor" aria-hidden="true" href="#哈希表">#</a></h3>
<p>哈希表是一种<strong>键值对</strong>的数据结构，它使用<strong>哈希函数组织数据</strong>，以支持<code>快速插入和搜索</code>。具体实现上，利用哈希函数将<strong>键映射到存储桶</strong>。更确切地说，当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；反之，当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。</p>
<p>实现方式：拉链法和开放寻址法。</p>
<ul>
<li>
<p><strong>开放寻址法</strong>：将冲突的键值对直接存储在哈希表中的其他位置。当发生冲突时，通过一定的探测序列（不同步长，如线性探测、二次探测等），在哈希表中寻找下一个可用的位置进行存储并特殊标记。</p>
<ul>
<li>插入数据：当我们往散列表中插入数据时，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</li>
<li>查找数据：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则，就顺序往后依次查找。如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。</li>
<li>删除数据：为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。最坏时间复杂度为O(n)。</li>
<li>二次探测（Quadratic probing）：线性探测每次探测的步长为1，即在数组中一个一个探测，而二次探测的步长变为原来的平方。</li>
<li>双重散列（Double hashing）：使用一组散列函数，直到找到空闲位置为止。线性探测法的性能描述：用“装载因子”来表示空位多少，公式：散列表装载因子=填入表中的个数/散列表的长度。装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</li>
</ul>
</li>
<li>
<p><strong>链表法</strong>：哈希表中的每个桶都是一个链表，当发生冲突时，新的键值对将被插入到链表的末尾。</p>
<ul>
<li>插入数据：当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)；</li>
<li>查找或删除数据：当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中槽的个数，所以是时间复杂度为O(k)。</li>
<li>让我们假设存储最大键数的桶有 N 个键。通常，如果 N 是常数且很小，我们可以简单地使用一个数组将键存储在同一个桶中。如果 N 是可变的或很大，我们可能需要使用高度平衡的二叉树（红黑树）来代替。</li>
</ul>
</li>
<li>
<p>再哈希法：使用不同的哈希函数来计算冲突键值对的哈希值。当发生冲突时，再次使用另一个哈希函数进行计算，直到找到一个可用的位置。</p>
</li>
<li>
<p>伪随机探测再散列：当发生哈希冲突时，伪随机探测再散列使用不同的探测序列来计算下一个可用的位置。它可以降低哈希表的聚集性，增加键值对的分散程度。</p>
</li>
<li>
<p>线性探测再散列：当发生哈希冲突时，通过逐个位置地查找下一个可用的位置来解决冲突。如果当前位置已被占用，则线性探测再散列算法会继续查找下一个位置，直到找到一个空闲的位置来存储冲突键值对。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="err">拉链法</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">h</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">ne</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">idx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 向哈希表中插入一个数
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">N</span> <span class="o">+</span> <span class="n">N</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">e</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ne</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">++</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 在哈希表中查询某个数是否存在
</span></span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">N</span> <span class="o">+</span> <span class="n">N</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">];</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ne</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="err">开放寻址法</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">h</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">N</span> <span class="o">+</span> <span class="n">N</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">!=</span> <span class="n">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span><span class="o">++</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="栈">栈<a hidden class="anchor" aria-hidden="true" href="#栈">#</a></h3>
<p>定义：操作受限的线性表，限定仅在表后端（栈顶）进行插入和删除操作的线性表。1、先进后出；2、显式栈实现 DFS。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// tt表示栈顶
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">stk</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">tt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 向栈顶插入一个数
</span></span></span><span class="line"><span class="cl"><span class="n">stk</span><span class="p">[</span><span class="o">++</span><span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 从栈顶弹出一个数
</span></span></span><span class="line"><span class="cl"><span class="n">tt</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 栈顶的值
</span></span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">stk</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 判断栈是否为空
</span></span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">tt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">	<span class="c1">// todo
</span></span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>单调栈：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 常见模型：找出每个数左边离它最近的比它大/小的数
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">tt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">tt</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="p">(</span><span class="n">stk</span><span class="p">[</span><span class="n">tt</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span> <span class="n">tt</span><span class="o">--</span><span class="p">;</span> <span class="c1">// check: 比它大/小的判断
</span></span></span><span class="line"><span class="cl"><span class="n">stk</span><span class="p">[</span><span class="o">++</span><span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span></code></pre></div><h3 id="队列">队列<a hidden class="anchor" aria-hidden="true" href="#队列">#</a></h3>
<p>定义：操作受限制的线性表，受限于只能在表前端删除（队头），表后端删除操作（对尾）。1、先进先出。</p>
<p>普遍队列：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// hh 表示队头，tt表示队尾
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">q</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">hh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 向队尾插入一个数
</span></span></span><span class="line"><span class="cl"><span class="n">q</span><span class="p">[</span><span class="o">++</span><span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 从队头弹出一个数
</span></span></span><span class="line"><span class="cl"><span class="n">hh</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 队头的值
</span></span></span><span class="line"><span class="cl"><span class="n">q</span><span class="p">[</span><span class="n">hh</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 判断队列是否为空
</span></span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">hh</span> <span class="o">&lt;=</span> <span class="n">tt</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">	<span class="c1">// todo
</span></span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>循环队列：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// hh 表示队头，tt表示队尾的后一个位置
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">q</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">hh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 向队尾插入一个数
</span></span></span><span class="line"><span class="cl"><span class="n">q</span><span class="p">[</span><span class="n">tt</span><span class="o">++</span> <span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">tt</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span> <span class="n">tt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 从队头弹出一个数
</span></span></span><span class="line"><span class="cl"><span class="n">hh</span><span class="o">++</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">hh</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span> <span class="n">hh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 队头的值
</span></span></span><span class="line"><span class="cl"><span class="n">q</span><span class="p">[</span><span class="n">hh</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 判断队列是否为空
</span></span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">hh</span> <span class="o">!=</span> <span class="n">tt</span><span class="p">){</span> 
</span></span><span class="line"><span class="cl">	<span class="c1">// todo
</span></span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="单调队列">单调队列<a hidden class="anchor" aria-hidden="true" href="#单调队列">#</a></h3>
<p>单调队列：deque，右边与当前值比较，增加当前值，左边与size比较。<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 常见模型：找出滑动窗口中的最大值/最小值
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">hh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 判断队头是否滑出窗口
</span></span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">hh</span> <span class="o">&lt;=</span> <span class="n">tt</span> <span class="o">&amp;&amp;</span> <span class="n">check_out</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">hh</span><span class="p">]))</span> <span class="n">hh</span><span class="o">++</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">hh</span> <span class="o">&lt;=</span> <span class="n">tt</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">tt</span><span class="p">],</span> <span class="n">i</span><span class="p">))</span> <span class="n">tt</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">q</span><span class="p">[</span> <span class="o">++</span> <span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="堆">堆<a hidden class="anchor" aria-hidden="true" href="#堆">#</a></h3>
<p>定义：一种由完全二叉树构成的数组对象数据结构，堆中某个结点的值总是不大于或不小于其父结点的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
</span></span></span><span class="line"><span class="cl"><span class="c1">// ph[k]存储第k个插入的点在堆中的位置
</span></span></span><span class="line"><span class="cl"><span class="c1">// hp[k]存储堆中下标是k的点是第几个插入的
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">h</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">ph</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">hp</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 交换两个点，及其映射关系
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">heap_swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">swap</span><span class="p">(</span><span class="n">ph</span><span class="p">[</span><span class="n">hp</span><span class="p">[</span><span class="n">a</span><span class="p">]],</span><span class="n">ph</span><span class="p">[</span><span class="n">hp</span><span class="p">[</span><span class="n">b</span><span class="p">]]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">swap</span><span class="p">(</span><span class="n">hp</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">hp</span><span class="p">[</span><span class="n">b</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">swap</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="n">b</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">down</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="n">t</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="n">t</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="n">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">heap_swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">down</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">up</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">u</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">heap_swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">u</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// O(n)建堆
</span></span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="n">down</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span></code></pre></div><h3 id="树">树<a hidden class="anchor" aria-hidden="true" href="#树">#</a></h3>
<p>定义：树是一种非线性的数据结构,它是由n(n&gt;=0)个有限节点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它跟朝上，而叶朝下。</p>
<p>类别：二叉树（每个节点至多两棵子树）、二叉搜索树（左&lt;根&lt;右）、满二叉树（‌每层结点数均达最大值的二叉树）、完全二叉树（除最后一层外每层节点数达到最大，且最后一层节点连续左对齐）、平衡二叉树（AVL树，它的任意结点的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1）、红黑树（<strong>自平衡的二叉搜索树</strong>‌，节点要么是红色要么是黑色，根节点必须是黑色且叶子节点是黑色，相同颜色节点不能相邻，每个节点到叶子节点的黑色节点数量相同）、N叉树</p>
<p>遍历：前序遍历（根左右）、中序遍（左根右）、后序遍历（左右根）、层序遍历、垂序遍历</p>
<p>重构：前序和中序、中序和后序、前序和后序。思路细节：1. 提前用数组记录每个节点索引；2. 左子树的大小；</p>
<p>祖先：<a href="https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/solutions/2305895/mo-ban-jiang-jie-shu-shang-bei-zeng-suan-v3rw/?envType=daily-question&amp;envId=2024-04-06">1483. 树节点的第 K 个祖先 - 力扣（LeetCode）</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="k">class</span> <span class="nc">TreeAncestor</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">     <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pa</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>  
</span></span><span class="line"><span class="cl">     <span class="n">TreeAncestor</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">         <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">__builtin_clz</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">// n 的二进制长度  
</span></span></span><span class="line"><span class="cl">         <span class="n">pa</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>  
</span></span><span class="line"><span class="cl">         <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">             <span class="n">pa</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl">         <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">             <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">                 <span class="k">if</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">];</span> <span class="n">p</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">                     <span class="n">pa</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl">     <span class="p">}</span>  
</span></span><span class="line"><span class="cl">     <span class="kt">int</span> <span class="nf">getKthAncestor</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">         <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">__builtin_clz</span><span class="p">(</span><span class="n">k</span><span class="p">);</span> <span class="c1">// k 的二进制长度  
</span></span></span><span class="line"><span class="cl">         <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">             <span class="k">if</span> <span class="p">((</span><span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// k 的二进制从低到高第 i 位是 1  
</span></span></span><span class="line"><span class="cl">                 <span class="n">node</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl">                 <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">             <span class="p">}</span>  
</span></span><span class="line"><span class="cl">         <span class="p">}</span>  
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="n">node</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">     <span class="p">}</span>  
</span></span><span class="line"><span class="cl"> <span class="p">};</span>
</span></span></code></pre></div><p>x和y的公共祖先：倍增法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="c1">// 返回 x 和 y 的最近公共祖先（节点编号从 0 开始）0 1 2 3 4  
</span></span></span><span class="line"><span class="cl"> <span class="kt">int</span> <span class="nf">get_lca</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// x=2 y=3  
</span></span></span><span class="line"><span class="cl">     <span class="k">if</span> <span class="p">(</span><span class="n">depth</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">depth</span><span class="p">[</span><span class="n">y</span><span class="p">])</span>  
</span></span><span class="line"><span class="cl">         <span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">     <span class="c1">// 使 y 和 x 在同一深度  
</span></span></span><span class="line"><span class="cl">     <span class="n">y</span> <span class="o">=</span> <span class="n">get_kth_ancestor</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">depth</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">-</span> <span class="n">depth</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span> <span class="c1">// y = 1 x = 2  
</span></span></span><span class="line"><span class="cl">     <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="n">x</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">     <span class="c1">// 不相等，  
</span></span></span><span class="line"><span class="cl">     <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">         <span class="kt">int</span> <span class="n">px</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">py</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="n">px</span> <span class="o">!=</span> <span class="n">py</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 不相等，最近公共祖先在更上一层，需要x和y往上一起跳，直到相等；相等，那么最近公共祖可能在pa[x][i]下面，由于无法往下跳，只能将i减一。  
</span></span></span><span class="line"><span class="cl">             <span class="n">x</span> <span class="o">=</span> <span class="n">px</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">             <span class="n">y</span> <span class="o">=</span> <span class="n">py</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">         <span class="p">}</span>  
</span></span><span class="line"><span class="cl">     <span class="p">}</span>  
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="n">pa</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl"> <span class="p">}</span>  
</span></span></code></pre></div><p>换根DP：<a href="https://leetcode.cn/problems/sum-of-distances-in-tree/solution/tu-jie-yi-zhang-tu-miao-dong-huan-gen-dp-6bgb/">【图解】一张图秒懂换根 DP！</a></p>
<p>原理：从0出发DFS，累加0到每个点的距离，得到基础值$ans[0]$。DFS的同时，计算出每棵子树的大小$size[i]$。然后从0出发再次DFS，设y是x的儿子，那么：$ans[y] = ans[x] + n - 2·size[y]$，利用该公式可以自顶向下递推得到每个$ans[i]$。</p>
<p>**本质：**交换两个节点的父子关系，对应的只有一对节点的距离变化量，其余关系不改变。</p>
<p>**子树大小如何计算？**所有儿子的子树大小之和 + 1；</p>
<p>**DFS如何保证树每个节点只递归访问一次？**树结构，只要判断是否等于父节点即可。</p>
<p>直径：树直径的概念，树中任意两点的最大距离被称为树的直径。以任意一点（例如0）开始遍历树：</p>
<p>定义$f[i]$表示i的子树中最大深度，$g[i]$表示子树中的次大深度，显然如果直径过点i，那么它的最大长度为</p>
<p>$$
diam = g[i] + f[i]<br>
$$</p>
<p>我们dfs的过程枚举每个点i取最大就好了，至于算f和g的值….</p>
<p>当计算$f[u]$和$g[u]$时，我们已经算好了$f[v]$和$g[v]$(v是u的儿子，并且这是个递归的过程，叶节点是终止条件)</p>
<p>使用$f[v] + 1$来更新$f[u]$、$g[u]$即可。这样求得树1的直径为diam1，树2直径为diam2</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="c1">// 直径  
</span></span></span><span class="line"><span class="cl"> <span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">fa</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">ans</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl"> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">     <span class="n">vis</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">     <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">v</span> <span class="p">:</span> <span class="n">vec</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">             <span class="k">continue</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">         <span class="p">}</span>  
</span></span><span class="line"><span class="cl">         <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">f</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">             <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">         <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">             <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">         <span class="p">}</span>  
</span></span><span class="line"><span class="cl">     <span class="p">}</span>  
</span></span><span class="line"><span class="cl">     <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span><span class="n">f</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">+</span><span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span>  
</span></span><span class="line"><span class="cl"> <span class="p">}</span>  
</span></span><span class="line"><span class="cl"> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"> <span class="k">auto</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">dfs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fa</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">     <span class="kt">int</span> <span class="n">max_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">     <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">y</span> <span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="n">fa</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">             <span class="kt">int</span> <span class="n">sub_len</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">             <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">max_len</span> <span class="o">+</span> <span class="n">sub_len</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">             <span class="n">max_len</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_len</span><span class="p">,</span> <span class="n">sub_len</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">         <span class="p">}</span>  
</span></span><span class="line"><span class="cl">     <span class="p">}</span>  
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="n">max_len</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"> <span class="p">};</span>  
</span></span><span class="line"><span class="cl"> <span class="n">dfs</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>  
</span></span></code></pre></div><h3 id="图">图<a hidden class="anchor" aria-hidden="true" href="#图">#</a></h3>
<p>有向无环图：拓扑排序</p>
<p> <strong>基环树</strong>：<a href="https://leetcode.cn/discuss/post/3581143/fen-xiang-gun-ti-dan-tu-lun-suan-fa-dfsb-qyux/">link</a>，dfs + 时间，拓扑排序删除非环部分 + dfs</p>
<p><strong>图的遍历思路</strong>：参考<a href="https://leetcode.cn/discuss/post/3581143/fen-xiang-gun-ti-dan-tu-lun-suan-fa-dfsb-qyux/">link</a>
1、dfs +（访问过数组） 找连通块 或者环。
2、bfs 求权值为1的最短路径，，单源最短路即计算某节点到各节点的最短路径。 进一步，还可以参考<a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/">847. 访问所有节点的最短路径</a>，结合状态压缩思想，计算到全部节点的最短路径。扩展到超图的最短路径<a href="https://leetcode.cn/problems/bus-routes/">815. 公交路线</a>，一条边可以连接超过两个节点的图。不断增加路径下的最短路径<a href="https://leetcode.cn/problems/shortest-distance-after-road-addition-queries-i/">3243. 新增道路查询后的最短距离 I</a>。甚至，<a href="https://leetcode.cn/problems/split-and-merge-array-transformation/">3690. 拆分合并数组</a>把状态抽象成图上的点，用 BFS 遍历这张图，计算从初始状态到目标状态的最短路长度。</p>
<h3 id="字典树">字典树<a hidden class="anchor" aria-hidden="true" href="#字典树">#</a></h3>
<p>ref: <a href="https://oi-wiki.org/string/trie/#%E7%BB%B4%E6%8A%A4%E5%BC%82%E6%88%96%E5%92%8C">字典树 (Trie) - OI Wiki (oi-wiki.org)</a></p>
<p>定义：一种<strong>空间换时间</strong>的树形数据结构，典型用于统计、排序、和保存大量字符串。与哈希表相比，字典树利用公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p>
<p>字典树有3个基本性质：（1）根节点不包含字符，除根节点外每一个节点都只包含一个字符；从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；（3）每个节点的所有子节点包含的字符都不相同。</p>
<p>字典序的数字：<a href="https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/solutions/1360934/by-livorth-u-zvxp/">440. 字典序的第K小数字 - 力扣（LeetCode）</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="k">class</span> <span class="nc">Trie</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">exist</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">};</span>     <span class="c1">// 确定字符串存在
</span></span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">size</span><span class="p">{</span><span class="n">INT_MAX</span><span class="p">};</span> <span class="c1">// 确定前缀字符串存在
</span></span></span><span class="line"><span class="cl">        <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">[</span><span class="mi">26</span><span class="p">]{};</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">{</span><span class="k">nullptr</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Trie</span><span class="p">()</span><span class="o">:</span><span class="n">root</span><span class="p">(</span><span class="k">new</span> <span class="n">Node</span><span class="p">()){}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Trie</span><span class="p">(){}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 插入字符串
</span></span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 前缀字符串最小长度
</span></span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 公共前缀字符串最小长度和索引
</span></span></span><span class="line"><span class="cl">        <span class="c1">//if(cur-&gt;size &gt; s.size()){
</span></span></span><span class="line"><span class="cl">        <span class="c1">//    cur-&gt;size = s.size();
</span></span></span><span class="line"><span class="cl">        <span class="c1">//    cur-&gt;exist = idx;
</span></span></span><span class="line"><span class="cl">        <span class="c1">//}
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span> <span class="c1">// 为空则创建
</span></span></span><span class="line"><span class="cl">            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">             <span class="c1">// 前缀字符串最小长度
</span></span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">                <span class="n">cur</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 公共前缀字符串最小长度和索引
</span></span></span><span class="line"><span class="cl">            <span class="c1">//if(cur-&gt;size &gt; s.size()){
</span></span></span><span class="line"><span class="cl">            <span class="c1">//    cur-&gt;size = s.size();
</span></span></span><span class="line"><span class="cl">            <span class="c1">//    cur-&gt;exist = idx;
</span></span></span><span class="line"><span class="cl">            <span class="c1">//}
</span></span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 字符串索引
</span></span></span><span class="line"><span class="cl">        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">exist</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">search</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 查找字符串对应的索引
</span></span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">exist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">searchStartWith</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 查找前缀字符串的最小长度
</span></span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">     
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">searchComStartWith</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 查找公共前缀字符串对应的索引
</span></span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">exist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">son</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="mi">26</span><span class="p">],</span> <span class="n">cnt</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">idx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 0号点既是根节点，又是空节点
</span></span></span><span class="line"><span class="cl"><span class="c1">// son[][]存储树中每个节点的子节点
</span></span></span><span class="line"><span class="cl"><span class="c1">// cnt[]存储以每个节点结尾的单词数量
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 插入一个字符串
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">son</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">u</span><span class="p">])</span> <span class="n">son</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">idx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span> <span class="o">=</span> <span class="n">son</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">u</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">cnt</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 查询字符串出现的次数
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">son</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">u</span><span class="p">])</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span> <span class="o">=</span> <span class="n">son</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">u</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">cnt</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="并查集">并查集<a hidden class="anchor" aria-hidden="true" href="#并查集">#</a></h3>
<p>ref: <a href="https://oi-wiki.org/ds/dsu/">并查集 - OI Wiki (oi-wiki.org)</a></p>
<p>并查集是一种树形的数据结构，顾名思义，它用于处理一些元素的 <strong>合并</strong> 及 <strong>查询</strong> 问题。它支持两种操作：查找（Find），确定某个元素处于哪个子集；合并（Union），将两个子集合并成一个集合。注意，并查集不支持集合的分离，但是并查集在经过修改后可以支持集合中单个元素的删除操作（详见 UVA11987 Almost Union-Find）。使用动态开点线段树还可以实现可持久化并查集。</p>
<p>操作：1、路径压缩，直接存储祖先节点。2、启发式合并，确保小合入大，优化合并操作复杂度。3、递归与非递归，非递归用while(true)搜索祖先节点</p>
<p>时间复杂度：同时使用<strong>路径压缩查找和启发式合并</strong>之后，并查集的每个操作平均时间仅为$O(\alpha(n))$，其中$\alpha$为阿克曼函数的反函数，其增长极其缓慢，也就是说其单次操作的平均运行时间可以认为是一个很小的常数。$O(log* n)$ 的时间复杂度已经很快了，$O(log* n)$是比 $O(logn)$ 还要快，近似等于 $O(1)$，比 $O(1)$慢一点。</p>
<p>空间复杂度：O(n)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="err">朴素并查集</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fa</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化，假定节点编号是1~n
</span></span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">fa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span> <span class="c1">// 路径压缩
</span></span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 合并
</span></span></span><span class="line"><span class="cl"><span class="n">fa</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 判断
</span></span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">IsConnect</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="err">维护</span><span class="n">size的并查集</span><span class="err">：</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fa</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化，假定节点编号是1~n
</span></span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">fa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 搜索
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 合并
</span></span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">size</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">size</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)];</span> <span class="c1">// 启发式合并，从小到大
</span></span></span><span class="line"><span class="cl"><span class="n">fa</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="err">维护到祖宗节点距离的并查集：</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fa</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化
</span></span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">fa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 搜索
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">		<span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">		<span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 合并，根据具体问题，初始化find(a)的偏移量
</span></span></span><span class="line"><span class="cl"><span class="n">fa</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">（</span><span class="mi">4</span><span class="err">）带权并查集</span> <span class="o">+</span> <span class="err">离散化</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化
</span></span></span><span class="line"><span class="cl"><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">fa</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 搜索
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">Find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">first</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">first</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">second</span> <span class="o">*=</span> <span class="n">fa</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 合并
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Union</span><span class="p">(</span><span class="kt">int</span> <span class="n">e1</span><span class="p">,</span><span class="kt">int</span> <span class="n">e2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">v</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="n">e1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="n">e2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">f1</span> <span class="o">!=</span> <span class="n">f2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">fa</span><span class="p">[</span><span class="n">f2</span><span class="p">].</span><span class="n">first</span> <span class="o">=</span> <span class="n">f1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">fa</span><span class="p">[</span><span class="n">f2</span><span class="p">].</span><span class="n">second</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="n">e1</span><span class="p">].</span><span class="n">second</span> <span class="o">*</span> <span class="n">v</span> <span class="o">/</span> <span class="n">fa</span><span class="p">[</span><span class="n">e2</span><span class="p">].</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="err">（</span><span class="mi">5</span><span class="err">）区间并查集</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fa</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化
</span></span></span><span class="line"><span class="cl"><span class="c1">// 初始化
</span></span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">fa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="c1">// 非递归并查集
</span></span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">re</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">rt</span><span class="p">]</span> <span class="o">!=</span> <span class="n">rt</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="n">rt</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="n">rt</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">rt</span><span class="p">]</span> <span class="o">!=</span> <span class="n">rt</span><span class="p">){</span> <span class="c1">// 节点
</span></span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">x</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">rt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 合并
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 并查集连通块个数
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fr</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">R</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">find</span><span class="p">(</span><span class="n">L</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">	<span class="n">fa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">（</span><span class="mi">6</span><span class="err">）二维并查集</span>
</span></span></code></pre></div><h3 id="子序列">子序列<a hidden class="anchor" aria-hidden="true" href="#子序列">#</a></h3>
<p>1、第一反应，排序</p>
<p>2、子序列贡献法</p>
<ol>
<li>
<p>以i作为端点，往左作为最大值，数量为2^{i}。</p>
</li>
<li>
<p>以i作为端点，往右作为最小值，数量为2^{n-1-i}。</p>
</li>
</ol>
<p>3、子序列DP</p>
<ol>
<li>
<p>相邻无关：0-1 背包</p>
</li>
<li>
<p>相邻相关：最长递增子序列</p>
</li>
<li>
<p>选或不选</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">差值绝对值的最小值</span> <span class="o">==</span><span class="err">》相邻相关</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="err">选或不选</span>  
</span></span><span class="line"><span class="cl"> <span class="err">​</span>  
</span></span><span class="line"><span class="cl"> <span class="err">递增子序列个数</span>  
</span></span><span class="line"><span class="cl"> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">pre</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl"> <span class="err">不选</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">pre</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl"> <span class="err">选</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  
</span></span><span class="line"><span class="cl"> <span class="err">​</span>  
</span></span><span class="line"><span class="cl"> <span class="n">i是当前下标</span>  
</span></span><span class="line"><span class="cl"> <span class="n">j是还需要选多少个数</span>  
</span></span><span class="line"><span class="cl"> <span class="n">pre</span><span class="err">·是上一个选的数</span>  
</span></span><span class="line"><span class="cl"> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">pre</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl"> <span class="err">​</span>  
</span></span><span class="line"><span class="cl"> <span class="n">i是当前下标</span>  
</span></span><span class="line"><span class="cl"> <span class="n">j是还需要选多少个数</span>  
</span></span><span class="line"><span class="cl"> <span class="n">pre</span><span class="err">·是上一个选的数</span>  
</span></span><span class="line"><span class="cl"> <span class="n">min_diff</span> <span class="err">目前选的数的能量</span>  
</span></span><span class="line"><span class="cl"> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">pre</span><span class="p">,</span><span class="n">min_diff</span><span class="p">)</span>  
</span></span></code></pre></div><p> 思路：</p>
<p> 1. 不选dfs(i-1, j, pre, min_diff)<br>
 2. 选dfs(i-1, j-1, nums[i], min(min_diff, pre-nums[i]))<br>
 3. j=0 返回min_diff<br>
 4. j &gt; i+1, 即使剩下的数全部选，也不足 j 个，返回0<br>
 5. 递归入口，dfs(n-1, k, INT_MAX, INT_MA)</p>
<p>字符串的子序列个数：具体来说，在遍历s的过程中，把<code>s[i]</code>加到前i-1个字符组成的不同子序列的末尾，同时把<code>s[i]</code>单独作为一个子序列，即得到了前i个字符以<code>s[i]</code>结尾的不同子序列的个数。遍历结束后把以<code>a,b,…,z</code>结尾的不同子序列的个数相加，就得到了答案。</p>
<p>有序子序列</p>
<p><a href="https://leetcode.cn/problems/find-the-k-sum-of-an-array/solutions/1764389/zhuan-huan-dui-by-endlesscheng-8yiq/?envType=daily-question&amp;envId=2024-03-09">2386. 找出数组的第 K 大和 - 力扣（LeetCode）</a></p>
<p><strong>如何不重不漏地生成 nums的所有子序列？</strong></p>
<p>以有序非负数组 nums=[1,2,3] 为例，有2^3=8个子序列，生成的方法如下：</p>
<ol>
<li>
<p>从空子序列 <a href="#"></a>[] 开始。</p>
</li>
<li>
<p>在 <a href="#"></a>[] 末尾添加 1 得到 [1]。</p>
</li>
<li>
<p>在 [1]末尾添加 2 得到 [1,2]。也可以把末尾的 1 替换成 2 得到 [2]。</p>
</li>
<li>
<p>在 [2]末尾添加 3 得到[2,3]。也可以把末尾的 2 替换成 3 得到 [3]。</p>
</li>
<li>
<p>在 [1,2] 末尾添加 3 得到 [1,2,3]。也可以把末尾的 2 替换成 3 得到[1,3]。</p>
</li>
</ol>
<p>上述过程结合最小堆，就可以按照从小到大的顺序生成所有子序列了（堆中维护子序列的和以及下一个要添加/替换的元素下标）。取生成的第 kkk 个子序列的和，作为 sum要减去的数。</p>
<p><strong>答疑</strong> 问：为什么结合最小堆，就一定是按元素和从小到大的顺序生成的？有没有可能先生成一个大的，再生成一个小的？</p>
<p>答：把子序列和它通过添加/替换生成的子序列之间连一条有向边，我们可以得到一棵以 [] 为根的有向树。把边权定义成相邻节点的子序列元素和的差，由于nums是有序的且没有负数，所以<strong>树是没有负数边权的</strong>。那么上述算法其实就是在这棵树上跑 <strong>Dijkstra 算法</strong>。把元素和当作海拔高度，算法执行过程就好比不断上涨的水位，我们会按照海拔高度从低到高淹没节点，所以出堆的元素和是非降的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"> <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="nl">x</span> <span class="p">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">     <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">         <span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">         <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">     <span class="p">}</span>  
</span></span><span class="line"><span class="cl"> <span class="p">}</span>  
</span></span><span class="line"><span class="cl"> <span class="err">​</span>  
</span></span><span class="line"><span class="cl"> <span class="err">​</span>  
</span></span><span class="line"><span class="cl"> <span class="n">ranges</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl"> <span class="err">​</span>  
</span></span><span class="line"><span class="cl"> <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"> <span class="n">pq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 空子序列  
</span></span></span><span class="line"><span class="cl"> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">     <span class="k">auto</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">     <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">     <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">         <span class="c1">// 在子序列的末尾添加 nums[i]  
</span></span></span><span class="line"><span class="cl">         <span class="n">pq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 下一个添加/替换的元素下标为 i+1  
</span></span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 替换子序列的末尾元素为 nums[i]  
</span></span></span><span class="line"><span class="cl">             <span class="n">pq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">         <span class="p">}</span>  
</span></span><span class="line"><span class="cl">     <span class="p">}</span>  
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="n">sum</span> <span class="o">-</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span></code></pre></div><h3 id="子数组子串">子数组/子串<a hidden class="anchor" aria-hidden="true" href="#子数组子串">#</a></h3>
<p>思路：</p>
<p>1、以<code>i</code>作为右端点的子数组，最暴力思路。OR 和 AND题型，<a href="https://leetcode.cn/problems/shortest-subarray-with-or-at-least-k-ii/solutions/2716483/zi-shu-zu-orandgcd-tong-yong-mo-ban-pyth-n8xj/">3097. 或值至少为 K 的最短子数组 II - 力扣（LeetCode）</a></p>
<p>2、将<strong>所有子串</strong>按照其末尾字符的下标分组。考虑两组<strong>相邻</strong>的子串：以 <code>s[i−1]</code> 结尾的子串、以 <code>s[i]</code> 结尾的子串。以 <code>s[i]</code> 结尾的子串，可以看成是以 <code>s[i−1]</code> 结尾的子串，在末尾添加上 <code>s[i]</code> 组成。最后分类讨论，之前没有遇到过/最前遇到过，推理出公式。<strong>上面这一串提示是思考子串统计类问题的通用技巧之一。</strong> <a href="https://leetcode.cn/problems/total-appeal-of-a-string/">2262. 字符串的总引力</a><a href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/">828. 统计子串中的唯一字符</a></p>
<h3 id="树状数组">树状数组<a hidden class="anchor" aria-hidden="true" href="#树状数组">#</a></h3>
<p>树状数组（Binary Indexed Tree），又称 Fenwick 树，将线性结构转化成树状结构，从而二进制搜索进行跳跃式扫描，一种有效的区间修改和区间查询O(log n) 的数据结构。</p>
<p>场景：区间和，区间个数（值域），区间异或，区间最大/最小值</p>
<p>建议：<a href="https://www.luogu.com.cn/problem/solution/P4392?page=1">link</a>，在考场上，面对功能极度全面的线段树O（Ologn），以及代码量少的树状数组O（nlognlogn），加以权衡。</p>
<p>问题点1：如何定义树状数组的大小。</p>
<p>答：与原数组一样大小，节省空间（开两倍的原数组就可，线段树需要开四倍原数组）；</p>
<p>问题点2：如何进位移动。</p>
<p>答：lowbit，x &amp; (-x)，把k的二进制的高位1全部清空；注意：无法处理0的情况，因为它的结果也是0，那么最终就是一个死循环。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Fenwick</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nl">pulic</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">tree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Fenwick</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span><span class="n">tree</span><span class="p">(</span><span class="n">n</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">v</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">x</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">	        <span class="n">tree</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span><span class="err">；</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">T</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">-=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">	        <span class="n">v</span> <span class="o">+=</span> <span class="n">tree</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Fenwick&lt;int&gt; s(n+1); // n = 1e5
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 场景一：单点修改，单点/区间查询 */</span>
</span></span><span class="line"><span class="cl"><span class="n">Fenwick</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span>  <span class="n">s</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 构造
</span></span></span><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span> <span class="c1">// 单点[1, x]修改v
</span></span></span><span class="line"><span class="cl"><span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// 单点[1, x]查询sum
</span></span></span><span class="line"><span class="cl"><span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 区间[l, r]查询
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 场景二：区间修改，区间查询 */</span>
</span></span><span class="line"><span class="cl"><span class="n">Fenwick</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">sx</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 构造
</span></span></span><span class="line"><span class="cl"><span class="c1">// 区间[l, r]修改v
</span></span></span><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="n">sx</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span><span class="o">*</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">sx</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span> <span class="n">l</span><span class="o">*</span><span class="n">s</span><span class="p">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">sx</span><span class="p">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="n">sx</span><span class="p">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 区间[l, r]查询sum
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 场景三、区间范围和 */</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1、先前缀和，再离散化，需要增加presum - low 和 presum -high。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 2、区间查询从[low, high] 变为[presum - high, presum - low]。
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 场景四、区间数，问题：区间内小于/大于val的个数。方案：单点修改，区间查询 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Fenwick</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 单点修改
</span></span></span><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// 区间查询 小于等于x的数量
</span></span></span><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// 区间查询 大于x的数量
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 场景五、离散化，数组排序，哈希存储*/</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sorted</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">sort</span><span class="p">(</span><span class="n">sorted</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sorted</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">mp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">mp</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">sorted</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mp</span><span class="p">[</span><span class="n">sorted</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pos</span><span class="o">++</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Fenwick</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 构造
</span></span></span><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">mp</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 先映射mp[x]，再修改
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 场景六：区间异或 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 场景七：区间最大值和最小值，改为区间和 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="c1">//添加一个数（不能修改）
</span></span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(;</span><span class="n">p</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">p</span><span class="o">+=</span><span class="n">p</span><span class="o">&amp;</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">mx</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">mx</span><span class="p">,</span><span class="n">x</span><span class="p">);</span><span class="c1">//维护区间的最大以及最小
</span></span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">mn</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">mn</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">mx</span><span class="o">=-</span><span class="mh">0x7f7f7f7f</span><span class="p">,</span><span class="n">mn</span><span class="o">=</span><span class="mh">0x7f7f7f7f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(;</span><span class="n">r</span><span class="o">-</span><span class="p">(</span><span class="n">r</span><span class="o">&amp;</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">))</span><span class="o">&gt;=</span><span class="n">l</span><span class="p">;</span><span class="n">r</span><span class="o">-=</span><span class="n">r</span><span class="o">&amp;</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">))</span><span class="c1">//标配
</span></span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">mx</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">mx</span><span class="p">,</span><span class="n">mx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">mn</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">mn</span><span class="p">,</span><span class="n">mn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">mx</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">mn</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">mn</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span><span class="o">--</span><span class="p">;</span><span class="c1">//不是所有区间都已处理，所以会多次维护
</span></span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">mx</span><span class="o">-</span><span class="n">mn</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">ci</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="前缀和">前缀和<a hidden class="anchor" aria-hidden="true" href="#前缀和">#</a></h3>
<p>定义：对于数组 nums，定义它的前缀和 $s[0] = 0$, $s[i+1] = \sum_{j=0}^{i} nums[j]$。例如 $nums[i] = [1, 2, -1, -2]$，对应的前缀和数组为$s = [0, 1, 3, 2, 4]$。通过前缀和，子数组的元素和转换成两个前缀和的差，即</p>
<p>$$
\sum_{j=left}^{right} nums[j] = \sum_{j=0}^{right} nums[j] - \sum_{j=0}^{left-1}nums[j] = s[right+1] - s[left]
$$</p>
<p>例如 nums的子数组$[2,-1,2]$的和就可以为是$s[4]-s[1]=4-1=3$。</p>
<blockquote>
<p>注：为方便计算，常用左开右闭区间$[left,right)$来表示子数组，此时子数组的和为$s[right]-s[left]$，子数组的长度为right-left。</p>
<p>注2：$s[0] = 0$ 表示的是一个空数组的元素和。为什么要额外定义它？想一想，如果要计算的子数组恰好是一个前缀（从$nums[0]$开始），你要用$s[right]$ 减去谁呢？通过定义$s[0]=0$，任意子数组（包括前缀）都可以表示为两个前缀和的差。</p>
</blockquote>
<p>二维/多维前缀和：多维前缀和的普通求解方法几乎都是基于容斥原理；前缀和公式：$(i,j)$表示当前位置</p>
<p>$$
sum_{ij} = sum_{i-1j} + sum_{ij-1} - sum_{i-1j-1} + a_{i}{j}
$$</p>
<p>区间和公式：$(x1,y1)$到$(x2,y2)$</p>
<p>$$
sum_{x2y2} - sum_{x1-1y2} - sum_{x2y1-1} + sum_{x1-1y1-1}
$$</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sumRegion</span><span class="p">(</span><span class="kt">int</span> <span class="n">r1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">sum</span><span class="p">[</span><span class="n">r2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">c2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sum</span><span class="p">[</span><span class="n">r2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">c1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sum</span><span class="p">[</span><span class="n">r1</span><span class="p">][</span><span class="n">c2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">sum</span><span class="p">[</span><span class="n">r1</span><span class="p">][</span><span class="n">c1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>基于 DP 计算高维前缀和：<a href="https://oi-wiki.org/basic/prefix-sum/#%E4%BA%8C%E7%BB%B4%E5%A4%9A%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">前缀和 &amp; 差分 - OI Wiki (oi-wiki.org)</a>，基于容斥原理来计算高维前缀和的方法，其优点在于形式较为简单，无需特别记忆，但当维数升高时，其复杂度较高。</p>
<p>设高维空间 $U$ 共有 $D$x 维，需要对 $f[\cdot]$ 求高维前缀和 $\text{sum}[\cdot]$。令$\text{sum}[i][\text{state}]$表示同 $\text{state}$ 后 D - i 维相同的所有点对于$ \text{state}$ 点高维前缀和的贡献。由定义可知 $\text{sum}[0][\text{state}] = f[\text{state}]$，以及 $\text{sum}[\text{state}] = \text{sum}[D][\text{state}]$。</p>
<p>其递推关系为$\text{sum}[i][\text{state}] = \text{sum}[i - 1][\text{state}] + \text{sum}[i][\text{state}&rsquo;]$，其中$\text{state}&rsquo;$ 为第 i 维恰好比 $\text{state}$ 少 1 的点。该方法的复杂度为 $O(D \times |U|)$，其中 $|U|$ 为高维空间 $U$ 的大小。</p>
<p>一种实现的伪代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">state</span>
</span></span><span class="line"><span class="cl">  <span class="n">sum</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">state</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">D</span><span class="p">;</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="err">以字典序从小到大枚举</span> <span class="n">state</span>
</span></span><span class="line"><span class="cl">    <span class="n">sum</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">[</span><span class="n">state</span><span class="err">&#39;</span><span class="p">];</span>
</span></span></code></pre></div><p>树上前缀和：设 $\textit{sum}_i$ 表示结点 i 到根节点的权值总和。然后：</p>
<ul>
<li>若是点权，x,y 路径上的和为 $\textit{sum}<em>x + \textit{sum}<em>y - \textit{sum}</em>\textit{lca} - \textit{sum}</em>{\textit{fa}_\textit{lca}}$。</li>
<li>若是边权，x,y 路径上的和为$\textit{sum}_x + \textit{sum}<em>y - 2\cdot\textit{sum}</em>{lca}$。
LCA 的求法参见 最近公共祖先。
<a href="https://loj.ac/p/2491">#2491. 「BJOI2018」求和 - 题目 - LibreOJ (loj.ac)</a></li>
</ul>
<h3 id="差分">差分<a hidden class="anchor" aria-hidden="true" href="#差分">#</a></h3>
<p>原理：<a href="https://oi-wiki.org/basic/prefix-sum/#%E5%B7%AE%E5%88%86">前缀和 &amp; 差分 - OI Wiki (oi-wiki.org)</a>，差分是一种和前缀和相对的策略，可以当做是求和的逆运算。</p>
<p>当我们希望对原数组的某一个区间[l,r]施加一个增量inc时，差分数组d对应的变化是：d[l]增加inc，d[r+1]减少inc，并且这种操作是可以叠加的。</p>
<p>作用：它可以维护多次对序列的一个区间加上一个数，并在最后询问某一位的数或是多次询问某一位的数。注意修改操作一定要在查询操作之前。</p>
<p><strong>一维差分</strong>——模板题 <a href="https://www.acwing.com/problem/content/799/">AcWing 797. 差分</a>：</p>
<pre tabindex="0"><code>给区间[l, r]中的每个数加上c：
B[l] += c
B[r + 1] -= c
</code></pre><p><strong>二维差分</strong>——模板题 <a href="https://www.acwing.com/problem/content/800/">AcWing 798. 差分矩阵</a>：</p>
<pre tabindex="0"><code>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c
S[x2 + 1, y1] -= c 
S[x1, y2 + 1] -= c
S[x2 + 1, y2 + 1] += c
</code></pre><p><strong>离散化差分</strong>：由于1e9的区间长度，需要进行离散化，思路是将出现的点升序排序并去重。对于每个点都映射为其排序后的下标。（用map实现）。</p>
<p><a href="https://leetcode.cn/problems/number-of-flowers-in-full-bloom/">2251. 花期内花的数目 - 力扣（LeetCode）</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fullBloomFlowers</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">flowers</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">persons</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">diff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">f</span> <span class="p">:</span> <span class="n">flowers</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">diff</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">            <span class="o">--</span><span class="n">diff</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">persons</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">id</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">iota</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">id</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">sort</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">id</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">persons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">persons</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">diff</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">diff</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&lt;=</span> <span class="n">persons</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                <span class="n">sum</span> <span class="o">+=</span> <span class="n">it</span><span class="o">++-&gt;</span><span class="n">second</span><span class="p">;</span> <span class="c1">// 累加变化量
</span></span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h3 id="线段树">线段树<a hidden class="anchor" aria-hidden="true" href="#线段树">#</a></h3>
<p><a href="https://oi-wiki.org/ds/seg/">线段树 - OI Wiki (oi-wiki.org)</a></p>
<p><a href="https://leetcode.cn/problems/range-module/solutions/1612955/by-lfool-eo50/">715. Range 模块 - 力扣（LeetCode）</a></p>
<p>前缀和、差分和线段树 都是工具，<strong>当我们遇到某些特定情况时才会使用</strong>：</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th>查询区间和</th>
          <th>修改区间（<strong>比如每个数</strong> +x)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>前缀和</td>
          <td>O(1)</td>
          <td>O(N)</td>
      </tr>
      <tr>
          <td>差分</td>
          <td>O(N)</td>
          <td>O(1)</td>
      </tr>
      <tr>
          <td>线段树</td>
          <td>O(logN)</td>
          <td>O(logN)</td>
      </tr>
  </tbody>
</table>
<ul>
<li>当我们需要较多的区间查询时，我们考虑前缀和；</li>
<li>当我们需要较多的区间修改时，我们考虑差分；</li>
<li>当我们两点都需要时，上板子（线段树）；</li>
</ul>
<p>线段树可以在$O(logN)$的时间复杂度内实现<strong>单点修改、区间修改、区间查询</strong>（区间求和，求区间最大值，求区间最小值)等操作。</p>
<p>区间求和：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SegMentTree</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// static cont inst N=1e5;
</span></span></span><span class="line"><span class="cl">    <span class="c1">// struct Node {
</span></span></span><span class="line"><span class="cl">    <span class="c1">//     int l, r, v, m;
</span></span></span><span class="line"><span class="cl">    <span class="c1">// } t[N&gt;&gt;1 + 1];
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span> <span class="o">*</span><span class="n">nl</span><span class="p">,</span> <span class="o">*</span><span class="n">nr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="o">:</span> <span class="n">l</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">r</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">v</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">m</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">nl</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">nr</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">SegMentTree</span><span class="p">()</span> <span class="p">{</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mf">1e9</span><span class="p">));</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">create</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">no</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">+</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">pushdown</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">no</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">+=</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">+=</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">+=</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">+=</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">no</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">pushup</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">no</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">no</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">,</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">build</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">no</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">no</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// a[i]
</span></span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">create</span><span class="p">(</span><span class="n">no</span><span class="p">);</span> <span class="c1">// 动态开点
</span></span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">build</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">build</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pushup</span><span class="p">(</span><span class="n">no</span><span class="p">);</span> <span class="c1">// 注意，创建时不需要下沉，直接上浮
</span></span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">no</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 当前更新区间[l, r] 不在目标区间;
</span></span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">||</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 当前更新区间[l, r] 全部在目标区间；
</span></span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">no</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">no</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 当前更新区间[l, r] 部分在目标区间
</span></span></span><span class="line"><span class="cl">        <span class="n">create</span><span class="p">(</span><span class="n">no</span><span class="p">);</span>   <span class="c1">// 动态开点
</span></span></span><span class="line"><span class="cl">        <span class="n">pushdown</span><span class="p">(</span><span class="n">no</span><span class="p">);</span> <span class="c1">// 下沉
</span></span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">+</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">update</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">update</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">pushup</span><span class="p">(</span><span class="n">no</span><span class="p">);</span> <span class="c1">// 上浮
</span></span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">no</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 当前搜索区间[l, r] 不在目标区间;
</span></span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">||</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 当前搜索区间[l, r] 全部在目标区间；
</span></span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 当前搜索区间[l, r] 部分在目标区间
</span></span></span><span class="line"><span class="cl">        <span class="n">create</span><span class="p">(</span><span class="n">no</span><span class="p">);</span>   <span class="c1">// 动态开点
</span></span></span><span class="line"><span class="cl">        <span class="n">pushdown</span><span class="p">(</span><span class="n">no</span><span class="p">);</span> <span class="c1">// 下沉
</span></span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">+</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ret</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">query</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ret</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">query</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">update</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">};</span><span class="k">class</span> <span class="nc">SegMentTree</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// static cont inst N=1e5;
</span></span></span><span class="line"><span class="cl">    <span class="c1">// struct Node {
</span></span></span><span class="line"><span class="cl">    <span class="c1">//     int l, r, v, m;
</span></span></span><span class="line"><span class="cl">    <span class="c1">// } t[N&gt;&gt;1 + 1];
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span> <span class="o">*</span><span class="n">nl</span><span class="p">,</span> <span class="o">*</span><span class="n">nr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="o">:</span> <span class="n">l</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">r</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">v</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">m</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">nl</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">nr</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">SegMentTree</span><span class="p">()</span> <span class="p">{</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mf">1e9</span><span class="p">));</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">create</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">no</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">+</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">pushdown</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">no</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">+=</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">+=</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">+=</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">+=</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">no</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">pushup</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">no</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">no</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">,</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">build</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">no</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">no</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// a[i]
</span></span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">create</span><span class="p">(</span><span class="n">no</span><span class="p">);</span> <span class="c1">// 动态开点
</span></span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">build</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">build</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pushup</span><span class="p">(</span><span class="n">no</span><span class="p">);</span> <span class="c1">// 注意，创建时不需要下沉，直接上浮
</span></span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">no</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 当前更新区间[l, r] 不在目标区间;
</span></span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">||</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 当前更新区间[l, r] 全部在目标区间；
</span></span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">no</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">no</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 当前更新区间[l, r] 部分在目标区间
</span></span></span><span class="line"><span class="cl">        <span class="n">create</span><span class="p">(</span><span class="n">no</span><span class="p">);</span>   <span class="c1">// 动态开点
</span></span></span><span class="line"><span class="cl">        <span class="n">pushdown</span><span class="p">(</span><span class="n">no</span><span class="p">);</span> <span class="c1">// 下沉
</span></span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">+</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">update</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">update</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">pushup</span><span class="p">(</span><span class="n">no</span><span class="p">);</span> <span class="c1">// 上浮
</span></span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">no</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 当前搜索区间[l, r] 不在目标区间;
</span></span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">||</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 当前搜索区间[l, r] 全部在目标区间；
</span></span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 当前搜索区间[l, r] 部分在目标区间
</span></span></span><span class="line"><span class="cl">        <span class="n">create</span><span class="p">(</span><span class="n">no</span><span class="p">);</span>   <span class="c1">// 动态开点
</span></span></span><span class="line"><span class="cl">        <span class="n">pushdown</span><span class="p">(</span><span class="n">no</span><span class="p">);</span> <span class="c1">// 下沉
</span></span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">+</span> <span class="n">no</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ret</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">query</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nl</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ret</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">query</span><span class="p">(</span><span class="n">no</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">update</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p><a href="https://zhuanlan.zhihu.com/p/106118909?utm_campaign=shareopn&amp;utm_medium=social&amp;utm_oi=935462374434041856&amp;utm_psn=1638707666246660096&amp;utm_source=wechat_session">算法学习笔记(14): 线段树 - 知乎 (zhihu.com)</a></p>
<p>区间取反：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">MX</span> <span class="o">=</span> <span class="mf">4e5</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">cnt</span><span class="p">[</span><span class="n">MX</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">flip</span><span class="p">[</span><span class="n">MX</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 维护区间 1 的个数
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">maintain</span><span class="p">(</span><span class="kt">int</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cnt</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">[</span><span class="n">o</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">cnt</span><span class="p">[</span><span class="n">o</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 执行区间反转
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">do_</span><span class="p">(</span><span class="kt">int</span> <span class="n">o</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cnt</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">cnt1</span><span class="p">[</span><span class="n">o</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="n">flip</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">flip</span><span class="p">[</span><span class="n">o</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化线段树   o,l,r=1,1,n
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">build</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">o</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cnt</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">o</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">o</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">maintain</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 反转区间 [L,R]   o,l,r=1,1,n
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">o</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">R</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">L</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">do_</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">flip</span><span class="p">[</span><span class="n">o</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">do_</span><span class="p">(</span><span class="n">o</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">do_</span><span class="p">(</span><span class="n">o</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">flip</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="n">L</span><span class="p">)</span> <span class="n">update</span><span class="p">(</span><span class="n">o</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">)</span> <span class="n">update</span><span class="p">(</span><span class="n">o</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">maintain</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Lazy 线段树：</p>
<h3 id="字符串">字符串<a hidden class="anchor" aria-hidden="true" href="#字符串">#</a></h3>
<p>定义：由零个或多个字符组成的有限序列。一般记为s=a1a2a3…an，在编程语言中表示文本的数据类型。</p>
<p>字符串连接：考虑可变性，C++字符串通过重载<code>+</code>运算符可改变，而python和java中无法改变，需要重新创建内存空间，再复制旧字符串中的内容到新字符串，多$O(n)$时间复杂度。如何解决方案该问题呢？答：转换成字符数组或其他数据结构。</p>
<p>字符串比较：c++和python中可以用==来比较字符串，java中无法用==比较字符串，实际上去比较这个两个对象是否是同一个对象。c++中可以用<code>s1.compare(s2)</code>。</p>
<p>字符串切片：python具有切片操作<code>str[start_pos: start_pos+len]</code>,而c++中可以用<code>str.substr(start_pos， len)</code>。</p>
<p>字符串遍历：（1）在C语言中，把一个字符串存入一个数组时，也把结束符 &lsquo;\0&rsquo;存入数组，并以此作为该字符串是否结束的标志。（2）在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用&rsquo;\0&rsquo;来判断是否结束。其实，在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。所以想处理字符串，我们还是会定义一个string类型。</p>
<p>字符串反转：（1）双指针：左指针指向头部，右指针指向尾部；（2）交换字符：临时变量，位运算，swap。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">reverseString</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="err">，</span> <span class="n">j</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="err">，</span><span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">swap</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="err">，</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>字符串分割：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">stringstream</span> <span class="nf">ss</span><span class="p">(</span><span class="n">sentence</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">w</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></div><p>字符串精度：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">stringstream</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">fixed</span> <span class="o">&lt;&lt;</span> <span class="n">setprecision</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;$&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">stoll</span><span class="p">(</span><span class="n">w</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ans</span> <span class="o">+=</span> <span class="n">s</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
</span></span></code></pre></div><p>字符串回文：一个正读和反读都一样的字符串。</p>
<p>1、回文字符串判断：1、反转比较；2、双指针。</p>
<p>2、若可以冗余删除一个或多个字符，递归思路。</p>
<p>3、最长回文字串：中心扩展算法（递归判断单字符或双字符的情况），动规。</p>
<p>4、回文字符串生成：仅考虑一半即可，反转相加得到回文字符串；</p>
<p>字符串子序列：从一个字符串中删除一些元素后，不改变剩下元素的顺序得到的字符串。</p>
<p>1、排序：一看到子序列，就想到排序。</p>
<p>2、子序列判断：采用双指针法，若字符相同，则指针往前一步，当t字符串遍历结束，查看s字符串是否达到字符串的最后一个位置，若是，返回true，否则，返回false。</p>
<p>3、子序列输出：回溯算法。</p>
<p>字符串子串：连续字符串。</p>
<p>1、滑动窗口：</p>
<p>2、前缀和 + 哈希表：</p>
<blockquote>
<p>前缀和：为方便计算，常用左闭右开区间$[\textit{left},\textit{right})$ 来表示子数组，此时子数组的和为 $s[right]−s[left]$，子数组的长度为 right−left。</p>
</blockquote>
<p>匹配：字符串匹配（String Matching）是计算机科学中的一个基础问题，它涉及到在一个主字符串（或称为文本）中查找一个或多个子字符串（或称为模式）的出现位置。字符串匹配算法在计算机编程、文本编辑器、搜索引擎、生物信息学等许多领域都有广泛的应用。<strong>简单来说，字符串s里查找模式串t！</strong></p>
<p>1、KMP：<a href="https://www.zhihu.com/question/21923021/answer/37475572">如何更好地理解和掌握 KMP 算法? - 知乎 (zhihu.com)</a>，Knuth，Morris和Pratt三位学者发明并以首字母命名为KMP算法，其主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong> 这是一种改进的字符串匹配算法，它利用已经匹配的信息来避免不必要的比较。KMP算法的核心是预处理子字符串，生成一个称为“部分匹配表”（Partial Match Table）的数据结构，用于在匹配失败时确定下一个比较的位置。KMP算法的时间复杂度是O(n+m)。</p>
<p>步骤一：计算最长公共前后缀<code>next[i]</code>，<strong>用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配</strong>。注意，前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串，后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。而公共前后缀实质上前缀相当于<code>字串</code>匹配的相同字串，后缀表示<code>原串</code>中的相同字符，因此可以根据这个来回退字串，继续匹配。如：<code>abcabcabf</code>和<code>abcabf</code>，当匹配到第5个字符时候，c和f不相等，子串应该回退到第2个字符位置继续匹配。</p>
<p>对于<code>abcabf</code>，$next[6]={0，0，0，1，2，0}$ 即a时，最长前后缀长度是0；即ab时，最长前后缀长度是0；即abc时，最长前后缀长度是0；即abca时，最长前后缀长度是1；即abcab时，最长前后缀长度是2；前2个字母后最后两个字母相等；即abcabf时，没有最长前后缀，长度是0；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">(</span><span class="n">m</span><span class="p">);</span> <span class="c1">// 公共前后缀  
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 注意i从1开始，第一个字符没有公共前后缀  
</span></span></span><span class="line"><span class="cl"> <span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">!=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 直到前后缀不相同  
</span></span></span><span class="line"><span class="cl">	 <span class="n">cnt</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// 向前回退  
</span></span></span><span class="line"><span class="cl"> <span class="p">}</span>  
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 字符匹配，具有相同的前后缀  
</span></span></span><span class="line"><span class="cl">	 <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"> <span class="p">}</span>  
</span></span><span class="line"><span class="cl"> <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>   <span class="c1">// 更新公共前后缀  
</span></span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>步骤二：在字符串s里找是否出现过模式串t。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 统计匹配次数  
</span></span></span><span class="line"><span class="cl"><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="cl"> <span class="k">while</span><span class="p">(</span><span class="n">cnt</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 直到前后缀不相同  
</span></span></span><span class="line"><span class="cl">	 <span class="n">cnt</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// 向前回退  
</span></span></span><span class="line"><span class="cl"> <span class="p">}</span>  
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 字符匹配，具有相同的前后缀  
</span></span></span><span class="line"><span class="cl">	 <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"> <span class="p">}</span>  
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 字符串s里匹配上模式串t  
</span></span></span><span class="line"><span class="cl">	 <span class="n">ans</span><span class="o">++</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">	 <span class="n">cnt</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl"> <span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>时间复杂度：n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)。</p>
<p>2、哈希匹配</p>
<p><strong>Rabin-Karp算法</strong>：这是一种基于哈希的字符串匹配算法，它利用哈希函数将字符串转换为数值，并通过比较这些数值来快速判断字符串是否匹配。Rabin-Karp算法的时间复杂度是O(n+m)，但它需要额外的空间来存储哈希值。</p>
<p>字符串哈希：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低，一个小技巧是取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64
</span></span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Hash</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">const</span> <span class="kt">int</span> <span class="n">mod1</span><span class="o">=</span><span class="mi">100663319</span><span class="p">,</span><span class="n">mod2</span><span class="o">=</span><span class="mi">201326611</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">const</span> <span class="n">LL</span> <span class="n">P1</span><span class="o">=</span><span class="mi">131</span><span class="p">,</span><span class="n">P2</span><span class="o">=</span><span class="mi">13331</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="n">LL</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">h1</span><span class="p">,</span><span class="n">h2</span><span class="p">,</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">p1</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="n">p2</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">h1</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="n">h2</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">t1</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="n">t2</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">         <span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">P1</span><span class="o">%</span><span class="n">mod1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">         <span class="n">p2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">p2</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">P2</span><span class="o">%</span><span class="n">mod2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">         <span class="n">h1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">h1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">P1</span><span class="o">%</span><span class="n">mod1</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;0&#39;</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">mod1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">         <span class="n">h2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">h2</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">P2</span><span class="o">%</span><span class="n">mod2</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;0&#39;</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">mod2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">         <span class="n">t1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">P1</span><span class="o">%</span><span class="n">mod1</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;0&#39;</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">mod1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">         <span class="n">t2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">t2</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">P2</span><span class="o">%</span><span class="n">mod2</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;0&#39;</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">mod2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="nf">getHash1</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">(</span><span class="n">h1</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="p">(</span><span class="n">h1</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p1</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">%</span><span class="n">mod1</span><span class="o">+</span><span class="n">mod1</span><span class="p">)</span><span class="o">%</span><span class="n">mod1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="nf">getHash2</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">(</span><span class="n">h2</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="p">(</span><span class="n">h2</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p2</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">%</span><span class="n">mod2</span><span class="o">+</span><span class="n">mod2</span><span class="p">)</span><span class="o">%</span><span class="n">mod2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="nf">getRevHash1</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">-</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p1</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">%</span><span class="n">mod1</span><span class="o">+</span><span class="n">mod1</span><span class="p">)</span><span class="o">%</span><span class="n">mod1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="nf">getRevHash2</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">(</span><span class="n">t2</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">-</span><span class="p">(</span><span class="n">t2</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p2</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">%</span><span class="n">mod2</span><span class="o">+</span><span class="n">mod2</span><span class="p">)</span><span class="o">%</span><span class="n">mod2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">Hash</span><span class="p">;</span>
</span></span></code></pre></div><h3 id="stl">STL<a hidden class="anchor" aria-hidden="true" href="#stl">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="p">,</span> <span class="err">变长数组，倍增的思想</span>
</span></span><span class="line"><span class="cl">    <span class="n">size</span><span class="p">()</span>  <span class="err">返回元素个数</span>
</span></span><span class="line"><span class="cl">    <span class="n">empty</span><span class="p">()</span>  <span class="err">返回是否为空</span>
</span></span><span class="line"><span class="cl">    <span class="n">clear</span><span class="p">()</span>  <span class="err">清空</span>
</span></span><span class="line"><span class="cl">    <span class="n">front</span><span class="p">()</span><span class="o">/</span><span class="n">back</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">push_back</span><span class="p">()</span><span class="o">/</span><span class="n">pop_back</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">begin</span><span class="p">()</span><span class="o">/</span><span class="n">end</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="err">支持比较运算，按字典序</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">first</span><span class="p">,</span> <span class="err">第一个元素</span>
</span></span><span class="line"><span class="cl">    <span class="n">second</span><span class="p">,</span> <span class="err">第二个元素</span>
</span></span><span class="line"><span class="cl">    <span class="err">支持比较运算，以</span><span class="n">first为第一关键字</span><span class="err">，以</span><span class="n">second为第二关键字</span><span class="err">（字典序）</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">string</span><span class="err">，字符串</span>
</span></span><span class="line"><span class="cl">    <span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="n">length</span><span class="p">()</span>  <span class="err">返回字符串长度</span>
</span></span><span class="line"><span class="cl">    <span class="n">empty</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">clear</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">substr</span><span class="p">(</span><span class="err">起始下标，</span><span class="p">(</span><span class="err">子串长度</span><span class="p">))</span>  <span class="err">返回子串</span>
</span></span><span class="line"><span class="cl">    <span class="n">c_str</span><span class="p">()</span>  <span class="err">返回字符串所在字符数组的起始地址</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">queue</span><span class="p">,</span> <span class="err">队列</span>
</span></span><span class="line"><span class="cl">    <span class="n">size</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">empty</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">push</span><span class="p">()</span>  <span class="err">向队尾插入一个元素</span>
</span></span><span class="line"><span class="cl">    <span class="n">front</span><span class="p">()</span>  <span class="err">返回队头元素</span>
</span></span><span class="line"><span class="cl">    <span class="n">back</span><span class="p">()</span>  <span class="err">返回队尾元素</span>
</span></span><span class="line"><span class="cl">    <span class="n">pop</span><span class="p">()</span>  <span class="err">弹出队头元素</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">priority_queue</span><span class="p">,</span> <span class="err">优先队列，默认是大根堆</span>
</span></span><span class="line"><span class="cl"><span class="err">优先级队列是一个拥有权值的</span><span class="n">queue</span><span class="err">，其内部元素按照元素的权值排列。权值较高者排在最前优先出队。其中缺省情况下系统是通过一个</span><span class="n">max</span><span class="o">-</span><span class="n">heap以堆实现完成排序特性</span><span class="err">，表现为一个以</span><span class="n">vector表现的完全二叉树</span><span class="err">。</span>
</span></span><span class="line"><span class="cl"><span class="err">操作：插入元素</span><span class="n">O</span><span class="p">(</span><span class="n">logn</span><span class="p">)</span><span class="err">、查询最大值</span><span class="n">O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="err">、删除最大值</span><span class="n">O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="err">；</span>
</span></span><span class="line"><span class="cl"><span class="err">底层：最大堆或最小堆；</span>
</span></span><span class="line"><span class="cl">    <span class="n">size</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">empty</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">push</span><span class="p">()</span>  <span class="err">插入一个元素</span>
</span></span><span class="line"><span class="cl">    <span class="n">top</span><span class="p">()</span>  <span class="err">返回堆顶元素</span>
</span></span><span class="line"><span class="cl">    <span class="n">pop</span><span class="p">()</span>  <span class="err">弹出堆顶元素</span>
</span></span><span class="line"><span class="cl">    <span class="err">定义成小根堆的方式：</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">stack</span><span class="p">,</span> <span class="err">栈</span>
</span></span><span class="line"><span class="cl">    <span class="n">size</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">empty</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">push</span><span class="p">()</span>  <span class="err">向栈顶插入一个元素</span>
</span></span><span class="line"><span class="cl">    <span class="n">top</span><span class="p">()</span>  <span class="err">返回栈顶元素</span>
</span></span><span class="line"><span class="cl">    <span class="n">pop</span><span class="p">()</span>  <span class="err">弹出栈顶元素</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">deque</span><span class="p">,</span> <span class="err">双端队列</span>
</span></span><span class="line"><span class="cl">    <span class="n">size</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">empty</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">clear</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">front</span><span class="p">()</span><span class="o">/</span><span class="n">back</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">push_back</span><span class="p">()</span><span class="o">/</span><span class="n">pop_back</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">push_front</span><span class="p">()</span><span class="o">/</span><span class="n">pop_front</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">begin</span><span class="p">()</span><span class="o">/</span><span class="n">end</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">set</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">multiset</span><span class="p">,</span> <span class="n">multimap</span><span class="p">,</span> <span class="err">基于平衡二叉树（红黑树），动态维护有序序列</span>
</span></span><span class="line"><span class="cl">    <span class="n">size</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">empty</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">clear</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">begin</span><span class="p">()</span><span class="o">/</span><span class="n">end</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="p">,</span> <span class="o">--</span> <span class="err">返回前驱和后继，时间复杂度</span> <span class="n">O</span><span class="p">(</span><span class="n">logn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">set</span><span class="o">/</span><span class="n">multiset</span>
</span></span><span class="line"><span class="cl">        <span class="n">insert</span><span class="p">()</span>  <span class="err">插入一个数</span>
</span></span><span class="line"><span class="cl">        <span class="n">find</span><span class="p">()</span>  <span class="err">查找一个数</span>
</span></span><span class="line"><span class="cl">        <span class="n">count</span><span class="p">()</span>  <span class="err">返回某一个数的个数</span>
</span></span><span class="line"><span class="cl">        <span class="n">erase</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="err">输入是一个数</span><span class="n">x</span><span class="err">，删除所有</span><span class="n">x</span>   <span class="n">O</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">logn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="err">输入一个迭代器，删除这个迭代器</span>
</span></span><span class="line"><span class="cl">        <span class="n">lower_bound</span><span class="p">()</span><span class="o">/</span><span class="n">upper_bound</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="n">lower_bound</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="err">返回大于等于</span><span class="n">x的最小的数的迭代器</span>
</span></span><span class="line"><span class="cl">            <span class="n">upper_bound</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="err">返回大于</span><span class="n">x的最小的数的迭代器</span>
</span></span><span class="line"><span class="cl">    <span class="n">map</span><span class="o">/</span><span class="n">multimap</span>
</span></span><span class="line"><span class="cl">        <span class="n">insert</span><span class="p">()</span>  <span class="err">插入的数是一个</span><span class="n">pair</span>
</span></span><span class="line"><span class="cl">        <span class="n">erase</span><span class="p">()</span>  <span class="err">输入的参数是</span><span class="n">pair或者迭代器</span>
</span></span><span class="line"><span class="cl">        <span class="n">find</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">[]</span>  <span class="err">注意</span><span class="n">multimap不支持此操作</span><span class="err">。</span> <span class="err">时间复杂度是</span> <span class="n">O</span><span class="p">(</span><span class="n">logn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">lower_bound</span><span class="p">()</span><span class="o">/</span><span class="n">upper_bound</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">unordered_set</span><span class="p">,</span> <span class="n">unordered_map</span><span class="p">,</span> <span class="n">unordered_multiset</span><span class="p">,</span> <span class="n">unordered_multimap</span><span class="p">,</span> <span class="err">哈希表</span>
</span></span><span class="line"><span class="cl">    <span class="err">和上面类似，增删改查的时间复杂度是</span> <span class="n">O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="err">不支持</span> <span class="n">lower_bound</span><span class="p">()</span><span class="o">/</span><span class="n">upper_bound</span><span class="p">()</span><span class="err">，</span> <span class="err">迭代器的</span><span class="o">++</span><span class="err">，</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">bitset</span><span class="p">,</span> <span class="err">圧位</span>
</span></span><span class="line"><span class="cl">    <span class="n">bitset</span><span class="o">&lt;</span><span class="mi">10000</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">,</span> <span class="o">|</span><span class="p">,</span> <span class="o">^</span>
</span></span><span class="line"><span class="cl">    <span class="o">&gt;&gt;</span><span class="p">,</span> <span class="o">&lt;&lt;</span>
</span></span><span class="line"><span class="cl">    <span class="o">==</span><span class="p">,</span> <span class="o">!=</span>
</span></span><span class="line"><span class="cl">    <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">count</span><span class="p">()</span>  <span class="err">返回有多少个</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">any</span><span class="p">()</span>  <span class="err">判断是否至少有一个</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="n">none</span><span class="p">()</span>  <span class="err">判断是否全为</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">set</span><span class="p">()</span>  <span class="err">把所有位置成</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="n">set</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>  <span class="err">将第</span><span class="n">k位变成v</span>
</span></span><span class="line"><span class="cl">    <span class="n">reset</span><span class="p">()</span>  <span class="err">把所有位变成</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="n">flip</span><span class="p">()</span>  <span class="err">等价于</span><span class="o">~</span>
</span></span><span class="line"><span class="cl">    <span class="n">flip</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="err">把第</span><span class="n">k位取反</span>
</span></span></code></pre></div><h2 id="算法">算法<a hidden class="anchor" aria-hidden="true" href="#算法">#</a></h2>
<h3 id="排序算法">排序算法<a hidden class="anchor" aria-hidden="true" href="#排序算法">#</a></h3>
<h3 id="双指针">双指针<a hidden class="anchor" aria-hidden="true" href="#双指针">#</a></h3>
<p>双指针法（快慢指针法）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</p>
<p>模板</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 双指针操作
</span></span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="n">j</span> <span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//a[i] ~ a[j] 都相等
</span></span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="滑动窗口">滑动窗口<a hidden class="anchor" aria-hidden="true" href="#滑动窗口">#</a></h3>
<p>ref：<a href="https://leetcode.cn/circle/discuss/0viNMK/">分享丨【题单】滑动窗口（定长/不定长/多指针） - 力扣（LeetCode）</a></p>
<p>原理：以i作为右端点，根据条件移动左端点，最后通过左右端点位置计算长度或者数量等。</p>
<p>定长：套路（右进左出，计算两个操作上区间变化）。</p>
<p>不定长：求最长/最大子数组、求最短/最小子数组、以及求子数组个数</p>
<ul>
<li>2.3 恰好性滑动窗口：转换成两个至少型滑动窗口，如<a href="https://leetcode.cn/problems/count-of-substrings-containing-every-vowel-and-k-consonants-ii/">3306. 元音辅音字符串计数 II</a>。</li>
</ul>
<p>多指针：</p>
<p>小技巧1：原地去重</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">ranges</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">nums</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">()),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// 原地去重
</span></span></span></code></pre></div><p><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/?envType=daily-question&amp;envId=2024-04-08">2009. 使数组连续的最少操作数 - 力扣（LeetCode）</a></p>
<p>思考1：双指针与滑动窗口区别？<a href="https://blog.csdn.net/wang_luwei/article/details/124182418">双指针与滑动窗口方法总结 - 悬浮海 - CSDN</a>：将计算过程仅与两端点相关的称为「双指针」，将计算过程与两端点表示的区间相关的称为「滑动窗口」。</p>
<h3 id="二分查找">二分查找<a hidden class="anchor" aria-hidden="true" href="#二分查找">#</a></h3>
<p>概念：<a href="https://oi-wiki.org/basic/binary/">二分 - OI Wiki (oi-wiki.org)</a>，用来在一个有序数组中查找某一元素的算法，比较中间元素与目标元素的匹配情况，从而减少一半区间；</p>
<p>时间复杂度：最优$O(1)$，平均和最坏$O(logn)$；</p>
<p>空间复杂度：迭代$O(1)$，递归$O(logn)$</p>
<p><strong style="color:red;">关键点</strong>：<strong>最大值最小化</strong>和<strong>最小值最大化</strong>，<a href="https://oi-wiki.org/basic/binary/#%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%8C%96">link</a>；</p>
<p>模板</p>
<p>1、区间$[l, r]$被划分成$[l, mid]$和$[mid + 1, r]$时候</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">check</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* ... */</span><span class="p">}</span> <span class="c1">// 检查x是否满足某种性质
</span></span></span><span class="line"><span class="cl"><span class="c1">// 区间可以考虑：left + （right- left）/2 = 0（向下取整）
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">bsearch</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// 辅助点
</span></span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">mid</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">            <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">ret</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>2、区间$[l, r]$被划分成$[l, mid - 1]$和$[mid, r]$时</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">check</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* ... */</span><span class="p">}</span> <span class="c1">// 检查x是否满足某种性质
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//区间可以考虑：（left + right + 1）/2 = 1
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">bsearch</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 辅助点
</span></span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">mid</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">            <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">ret</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意：浮点数，<code>r - l &gt; 1e-6</code>；</p>
<p>注意：对于n是有符号数的情况，当你可以保证 $n\ge 0$时，<code>n &gt;&gt; 1</code> 比 <code>n / 2</code> 指令数更少。</p>
<p>API</p>
<p><code>std::lower_bound</code>：查找首个不小于给定值的元素的函数；</p>
<p><code>std::upper_bound</code>：查找首个大于给定值的元素的函数；</p>
<h3 id="三分查找">三分查找<a hidden class="anchor" aria-hidden="true" href="#三分查找">#</a></h3>
<p>三分法与二分法的基本思想类似，但每次操作需在当前区间 $[l, r]$内任取两点 $[lmid,rmid]$。如果 $f(lmid)&lt;f(rmid)$，则在 $[rmid,r]$中函数必然单调递增，最小值所在点必然不在这一区间内，可舍去这一区间。反之亦然。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lmid</span> <span class="o">+</span> <span class="n">rmid</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">lmid</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">eps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rmid</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">eps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">lmid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">(</span><span class="n">rmid</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="贪心">贪心<a hidden class="anchor" aria-hidden="true" href="#贪心">#</a></h3>
<p>link: <a href="https://leetcode.cn/circle/discuss/g6KTKL/">https://leetcode.cn/circle/discuss/g6KTKL/</a></p>
<p>贪心策略：</p>
<p>1、排序前提，从最小/最大开始贪心，优先考虑最小/最大的数。在此基础上，衍生出了反悔贪心。</p>
<p>2、从最左/最右开始贪心，思考第一个数/最后一个数的贪心策略，把 n 个数的原问题转换成 n−1 个数（或更少）的子问题。</p>
<h3 id="反悔贪心">反悔贪心<a hidden class="anchor" aria-hidden="true" href="#反悔贪心">#</a></h3>
<p><strong>反悔贪心：</strong> 堆存储可返回的对象，当条件限制，在弹出最后的。</p>
<h3 id="位运算">位运算<a hidden class="anchor" aria-hidden="true" href="#位运算">#</a></h3>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>题目</th>
          <th>题解</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>0001</td>
          <td>给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？</td>
          <td>1.位运算，数组异或，所有数异或，二者异或，找到一位异或值不为0的标志位，标志位mask与数组异或，再与所有数异或，得到第一个数，再与二者异或值异或，得到第二个数；<br />2.diff = (sumTwo)/2;一个数大于二者和的一半，一个数小于二者的一半；小于diff求和，再计算总数一半和，相减即可，得到其中一个值；<br />3. a+b,和a^2 + b^2，通过求和公式和求平方((1 + n) * n / 2)和公式（n * (n + 1) * (2 * n + 1) / 6），解方程即可；</td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">__builtin_popcount</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span></code></pre></div><h3 id="动态规划">动态规划<a hidden class="anchor" aria-hidden="true" href="#动态规划">#</a></h3>
<p><strong>数位DP</strong>：（1）只需要考虑是否受到前一个数的约束，考虑上下界；（2）受约束时的状态只会递归访问一次，不需要记录。参考：<a href="https://leetcode.cn/problems/count-the-number-of-powerful-integers/">2999. 统计强大整数的数目</a>，灵神解析<a href="https://leetcode.cn/problems/count-the-number-of-powerful-integers/solutions/2595149/shu-wei-dp-shang-xia-jie-mo-ban-fu-ti-da-h6ci/?envType=daily-question&amp;envId=2025-04-10">link</a>。</p>
<p><strong>树上DP</strong>：思路上考虑子树和非子树的区别，从而DP计算结果。<a href="https://leetcode.cn/problems/sum-of-distances-in-tree/">834. 树中距离之和</a></p>
<h3 id="数学最大公约数">数学：最大公约数<a hidden class="anchor" aria-hidden="true" href="#数学最大公约数">#</a></h3>
<p>原理：最大公约数，能够同时整除它们的最大的正整数。采用<strong>gcd</strong>辗转相除法，又称欧几里得算法（Euclidean algorithm），较小的数和两数相除余数的最大公约数：</p>
<p>$$
gcd(a,b) = gcd(b, a % b)
$$</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">);}</span>
</span></span></code></pre></div><p>复杂度：时间复杂度：$log_{2}(n)$，空间复杂度：$log(1)$。</p>
<p>性质；（1）gcd(a, b) = 1，称a和b互素；（2）gcd(a, a) = a；（3）$gcd(x,y)=gcd(x,y-x)$；（4）若x,y均为偶数，则$gcd(x,y)=2*gcd(x/2.y/2)$;（5）若x为偶数，y为奇数，则$gcd(x,y)=gcd(x/2,y)$;（6）若x为奇数，y为偶数，则$gcd(x,y)=gcd(x,y/2)$;</p>
<p>题型：</p>
<p>（1）预处理每个数因子<a href="https://leetcode.cn/problems/count-equal-and-divisible-pairs-in-an-array/solutions/1277713/mo-ni-by-endlesscheng-wegn/?envType=daily-question&amp;envId=2025-04-17">link</a>，遍历每个数，从i递增到MX，步长=i；（2）两数乘积的<strong>整除</strong>。</p>
<p>（2）<a href="https://www.luogu.com.cn/problem/list?keyword=gcd&amp;page=1">gcd - 洛谷</a>，给定正整数 <em>n</em>，求 1≤<em>x</em>,<em>y</em>≤<em>n</em> 且 gcd(<em>x</em>,<em>y</em>) 为素数的数对(<em>x</em>,<em>y</em>) 有多少对。</p>
<p>（3）$T$ 组数据，每一组数据给定 $l,r,x$，试求：$\gcd(\lfloor \frac{l}{x}\rfloor,\lfloor \frac{l+1}{x}\rfloor,\cdots,\lfloor \frac{r}{x}\rfloor)$ 的值。破题点：连续整数；$gcd(c,c+1)=1$。</p>
<h3 id="数学数的幂次方">数学：数的幂次方<a hidden class="anchor" aria-hidden="true" href="#数学数的幂次方">#</a></h3>
<p>2的幂：</p>
<ul>
<li>暴力：通过for循环取余除2判断。</li>
<li>位运算：(1) 通过左位移操作，列举出 int 型内的全部2的幂次方（32次），是否相等；(2) $n &amp; (n-1)$，若n为2的幂次方，则n-1正好与n没有一位的相同。</li>
<li>数学：n 是否是 230230 的约数即可。</li>
</ul>
<p>模板：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 位运算
</span></span></span><span class="line"><span class="cl"><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 数学
</span></span></span><span class="line"><span class="cl"><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span><span class="err">#</span>  <span class="n">n</span> <span class="err">是否是</span> <span class="mi">230230</span> <span class="err">的约数即可</span>
</span></span></code></pre></div><p>复杂度：</p>
<ul>
<li>时间复杂度：$O(1)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<p><a href="https://leetcode.cn/problems/convert-to-base-2/">负二进制转换</a>：判断当前位是否使用，判断是不是2的倍数即可，是就跳过，不是就使用填补。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">baseNeg2</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="s">&#34;0&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">string</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">&#39;1&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">n</span> <span class="o">-=</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">k</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">n</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">reverse</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ans</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h3 id="数学快速幂">数学：快速幂<a hidden class="anchor" aria-hidden="true" href="#数学快速幂">#</a></h3>
<p>快速幂：以$log(n)$的时间复杂度计算乘方，<a href="https://zhuanlan.zhihu.com/p/95902286">算法学习笔记(4)：快速幂 - 知乎 (zhihu.com)</a>。</p>
<p>原理：递归快速幂，二分思想，计算a的n次方，如果n是偶数（不为0），那么就<strong>先计算a的n/2次方，然后平方</strong>；如果n是奇数，那么就<strong>先计算a的n-1次方，再乘上a</strong>；递归出口是<strong>a的0次方为1</strong>。注意：递归虽然<strong>简洁</strong>，但会产生<strong>额外的空间开销</strong>。</p>
<p>$$
a^{n}=\left{\begin{array}{ll}a^{n-1} \cdot a, &amp; \text { if } n \text { is odd } \ a^{\frac{n}{2}} \cdot a^{\frac{n}{2}}, &amp; \text { if } n \text { is even but not } 0 \ 1, &amp; \text { if } n=0\end{array}\right.
$$</p>
<p>非递归快速幂：以二进制展开，$x^{10} = x^{(1010)<em>{2}} = x^{(1000)</em>{2}} * x^{(10)_{2}} = x^{2} * x^{8}$，而 $7^{x}$只需<strong>不断把底数平方</strong>就可以算出它们。</p>
<p>如，最初ans为1，然后我们一位一位算，1010的最后一位是0，所以$a^1$这一位不要。然后1010变为101，a变为$a^2$。101的最后一位是1，所以$a^{2}$这一位是需要的，乘入ans。101变为10，a再自乘。10的最后一位是0，跳过，右移，自乘。然后1的最后一位是1，ans再乘上$a^8$。循环结束，返回结果。</p>
<p>模板：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//非递归快速幂
</span></span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="mf">1e9</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">long</span> <span class="kt">long</span> <span class="nf">qpow</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="kt">long</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">%=</span> <span class="n">mod</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span>   <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">*</span> <span class="n">a</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>复杂度：；时间复杂度：$O(logn)$，空间复杂度：迭代$O(1)$和递归不确定是$O(n)$。</p>
<p>扩展：任意类型，在算 $a^{n}$时，只要a的数据类型支持<strong>乘法</strong>且<strong>满足结合律</strong>，快速幂的算法都是有效的。如，矩阵、高精度整数。</p>
<p>题型：<a href="https://www.luogu.com.cn/problem/P1962">P1962 斐波那契数列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h3 id="数学质数">数学：质数<a hidden class="anchor" aria-hidden="true" href="#数学质数">#</a></h3>
<p><a href="https://oi-wiki.org/math/number-theory/sieve/">筛法 - OI Wiki (oi-wiki.org)</a></p>
<p>定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。</p>
<p>质数：2到$\sqrt{n}$，是否整除n。</p>
<p>质数筛：线性筛，2到n，i是质数则存，以质数数组 * i 标记后续所有数，由于仅考虑最小质因数筛，i%质数为0退出。</p>
<h3 id="数学连续和">数学：连续和<a hidden class="anchor" aria-hidden="true" href="#数学连续和">#</a></h3>
<p>思路：求和公式 + 限定条件，<a href="https://leetcode.cn/problems/consecutive-numbers-sum/">829. 连续整数求和</a>，参考题解<a href="https://leetcode.cn/problems/consecutive-numbers-sum/solutions/3010681/cdeng-chai-shu-lie-by-xie-ding-e-de-mao-ck22w/">link</a>。</p>
<h3 id="数学曼哈顿距离">数学：曼哈顿距离<a hidden class="anchor" aria-hidden="true" href="#数学曼哈顿距离">#</a></h3>
<p><a href="https://leetcode.cn/problems/minimize-manhattan-distances/solutions/2716755/tu-jie-man-ha-dun-ju-chi-heng-deng-shi-b-op84/">3102. 最小化曼哈顿距离 - 力扣（LeetCode）</a></p>
<p>切比雪夫距离：$(x, y) -&gt; (x&rsquo; =x + y, y&rsquo;=y - x)$，顺时针旋转45°（放大$\sqrt{2}$），新坐标系投影到x’轴或者y’轴(缩小$\sqrt{2}$​)。</p>
<p>最小化曼哈顿距离：</p>
<p>$$
\left|x_{1}-x_{2}\right|+\left|y_{1}-y_{2}\right|=\max \left(\left|x_{1}^{\prime}-x_{2}^{\prime}\right|,\left|y_{1}^{\prime}-y_{2}^{\prime}\right|\right)
$$</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">xx2</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">y1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">yy2</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">x1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">xx2</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">y2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">yy2</span> <span class="o">=</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">x2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">dis</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">xx1</span> <span class="o">-</span> <span class="n">xx2</span><span class="p">,</span> <span class="n">yy1</span> <span class="o">-</span> <span class="n">yy2</span><span class="p">);</span>
</span></span></code></pre></div><h3 id="数学容斥原理">数学：容斥原理<a hidden class="anchor" aria-hidden="true" href="#数学容斥原理">#</a></h3>
<p><a href="https://leetcode.cn/problems/nth-magical-number/solutions/1984641/er-fen-da-an-rong-chi-yuan-li-by-endless-9j34/">878. 第 N 个神奇数字 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/kth-smallest-amount-with-single-denomination-combination/solutions/2739213/er-fen-sou-suo-rong-chi-yuan-li-by-mipha-gewj/">100267. 单面值组合的第 K 小金额 - 力扣（LeetCode）</a></p>
<p><strong>k 小问题有三种解法</strong>：(1)按位确定答案（多用于字符串和二进制数）；（2）用堆维护当前最小答案（用于 k 比较小的情况）；（3）二分 + 容斥（用于 k 比较大的情况）。</p>
<p><strong>容斥原理</strong>：</p>
<p>如果有A、B两种，则</p>
<p>$$
\begin{array}{c}A \cup B =A+B-A \cap B \= \frac{n u m}{A}+\frac{n u m}{B}-\frac{n u m}{\operatorname{LCM}(A, B)}\end{array}
$$</p>
<p>如果有A、B、C三种，则</p>
<p>$$
\begin{array}{c}A \cup B \cup C=A+B+C-A \cap B-B \cap C-C \cap A+A \cap B \cap C \= \frac{n u m}{A}+\frac{n u m}{B}+\frac{n u m}{C}-\frac{n u m}{\operatorname{LCM}(A, B)}-\frac{\text { num }}{\operatorname{LCM}(B, C)}-\frac{\text { num }}{\operatorname{LCM}(C, A)}+\frac{\text { num }}{\operatorname{LCM(A,B,C)}}\end{array}
$$</p>
<p>如果有k种，本质上正负正负交替，则</p>
<p>$$
(-1)^{k-1}\left\lfloor\frac{m}{l c m}\right\rfloor
$$</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">check</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">m</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="kt">long</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">coins</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 枚举所有非空子集
</span></span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="kt">long</span> <span class="n">lcm_res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 计算子集 LCM
</span></span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">coins</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">lcm_res</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span><span class="n">lcm_res</span><span class="p">,</span> <span class="n">coins</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">lcm_res</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 太大了
</span></span></span><span class="line"><span class="cl">                    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">cnt</span> <span class="o">+=</span> <span class="n">__builtin_popcount</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">?</span> <span class="n">m</span> <span class="o">/</span> <span class="nl">lcm_res</span> <span class="p">:</span> <span class="o">-</span><span class="n">m</span> <span class="o">/</span> <span class="n">lcm_res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h3 id="数学第k大">数学：第k大<a hidden class="anchor" aria-hidden="true" href="#数学第k大">#</a></h3>
<p>第k个排列：<a href="http://leetcode.cn/problems/smallest-palindromic-rearrangement-ii/solutions/3649533/shi-tian-fa-zu-he-shu-xue-pythonjavacgo-qlu6e/">link</a></p>
<h3 id="数学因式分解">数学：因式分解<a hidden class="anchor" aria-hidden="true" href="#数学因式分解">#</a></h3>
<p><a href="https://leetcode.cn/problems/count-the-number-of-ideal-arrays/solutions/1659088/shu-lun-zu-he-shu-xue-zuo-fa-by-endlessc-iouh/?envType=daily-question&amp;envId=2025-04-22">link</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// EXP[x] 为 x 分解质因数后，每个质因数的指数
</span></span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">MAX_N</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(;</span> <span class="n">t</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">/=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">e</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">EXP</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">EXP</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="数学组合数">数学：组合数<a hidden class="anchor" aria-hidden="true" href="#数学组合数">#</a></h3>
<p>选和不选，<code>C(n,k)=C(n−1,k)+C(n−1,k−1)</code>，初始值<code>C(n,0)=1</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 预处理组合数
</span></span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_N</span> <span class="o">+</span> <span class="n">MAX_K</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">MAX_K</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="n">MOD</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<ul>
<li>:[^01] ref: <a href="%E5%9C%B0%E5%9D%80">作者-文章-来源</a></li>
</ul>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://yangly0.github.io/tags/%E6%8A%80%E6%9C%AF/">技术</a></li>
      <li><a href="https://yangly0.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://yangly0.github.io/posts/20241123215151/">
    <span class="title">« 上一页</span>
    <br>
    <span>如何搭建一个博客系统？</span>
  </a>
</nav>

  </footer><div id="twikoo"></div>
<script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js"></script>
<script>
  twikoo.init({
    envId: "https://twikoo.yangly1993.top/", 
    el: "#twikoo",
    lang: "zh-CN",
    
    onCommentLoaded: function() {
      
      
    }
  });
</script>
</article>
    </main>
    
<footer class="footer">
        <span>©<a href="https://github.com/Yangly0">Yangly</a> | Since 2024 | <a href="https://beian.miit.gov.cn/">渝ICP备2025051440号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
</body>

</html>
