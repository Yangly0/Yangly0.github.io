[{"content":"摘要：\n如何把2D图像特征转换到3D空间？ 1、BEVFormer类的算法思想采用Transformer的注意力机制基于查询的方法去获取三维BEV特征。缺陷是注意力机制的运算操作对某些计算平台可能不太友好。\n$$ F_{b e v}(x, y, z)=\\operatorname{Attn}(q, k, v) $$\n注意力机制的运算操作 不友好点？\n1、计算复杂度高，O(N^2), N表示序列长度，稀疏性Attention可降低到O(LlogL), 甚至O(L)\n2、存储空间过大\n2、BEVDet类的算法思想通过计算二维特征与预测深度的外积来获得三维BEV特征。缺陷是仅适用于cuda推理库等加速平台，非推理库加速平台部署困难，而且更大的分辨率和特征维度则会遇到计算性能瓶颈。\n$$ F_{b e v}(x, y, z)=\\operatorname{Pool}\\left{F_{2 D}(u, v) \\otimes D(u, v)\\right}_{x, y, z} $$\n考虑到之前的视图变换方法都比较耗时，作者基于M2BEV中提出的沿相机光线方向深度是均匀分布的假设，提出了Fast-Ray视图变换方法，这种方法将多视图的2D图像特征沿相机光线投射到3D体素空间中。该方法的优点是，只要知道相机的内外参，就可以很容易地计算出2D到3D的投影关系。由于这个过程中没有使用可学习的参数，因此可以很容易地计算出图像特征点和BEV特征点之间的对应关系矩阵。\n沿相机光线方向深度是均匀分布假设：//\n1、\nhttps://zhuanlan.zhihu.com/p/709461901\n:[^01] ref: 作者-文章-来源 ","permalink":"https://yangly0.github.io/posts/output/2025/20250122094438/","summary":"\u003cp\u003e摘要：\u003c/p\u003e","title":"FastBev"},{"content":"摘要：一种设计模式——策略模式！\npolicy-base的做法是正交分割+多继承+模版限定上下文\n1、继承：基类定义接口，子类进行实现。缺点是派生类过多，更深层次的继承结构，两个类似实现重复，造成难于扩展和维护。\n1 2 3 4 class animal; class dog: public animal{ void call(int times) const override; }; 2、策略模式：采用模板实现重载，进行类型分发，如不同迭代器类型，std:advacne的策略不同。可以在模板中指定特殊的策略，比如std:priority_queue默认是大根堆，可以在模板指定不同策略；unique_ptr+的deleter可以自己指定删除策略。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class dog; class dog_strategy{ virtual void call(const dog\u0026amp; d, int time) const = 0; }; class dog:public animal{ dog(..., std::qunique_ptr\u0026lt;dog_strategy\u0026gt; s) :calling(std::move(s)) {} void call(int times) const override{ calling-\u0026gt;call(*this,times); } std::unique_ptr\u0026lt;dog_strategy\u0026gt; calling; }; class Husky_strategy : public dog_strategy; // std::unique_ptr\u0026lt;animal\u0026gt; = std::make_unique\u0026lt;dog(0,std::make_unique\u0026lt;Husky_strategy\u0026gt;()); 3、类型擦除：借助两个类型，实现类型擦除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 void calling(const Husky\u0026amp; d,int times){} void calling(const Siamese\u0026amp; d,int times){} class animal { private: struct animal_concept { virtual ~animal_concept(){} virtual void call(int times) const = 0; virtual std::unique_ptr\u0026lt;animal_concept\u0026gt; clone() const = 0; }; template\u0026lt;typename T\u0026gt; struct animal model public animal concept { template\u0026lt;typename...Args\u0026gt; animal_model(Args\u0026amp;\u0026amp;...val)object(std:forward\u0026lt;Args\u0026gt;(val)...){} std:unique_ptr\u0026lt;animal_concept\u0026gt;clone（）const override { return std:make_unique\u0026lt;animal_model\u0026gt;(*this); } void call(int times)const override { calling(object,times); } T object; }; friend void call(const animal\u0026amp;a,int times){ a.pimpl-\u0026gt;call(times); } std:unique_ptr\u0026lt;animal_concept\u0026gt;pimpl; public: template\u0026lt;typename T\u0026gt; animal(T\u0026amp;\u0026amp;x):pimpl{new animal_model\u0026lt;T\u0026gt;(std:move(x))}{} template\u0026lt;typename T\u0026gt; animal(const T\u0026amp;x):pimpl{new animal_model\u0026lt;T\u0026gt;(x)}{} animal(const animal\u0026amp;other); animal\u0026amp;operator=(const animal\u0026amp;other); animal(animal\u0026amp;\u0026amp;a); animal\u0026amp;operator+=(animal\u0026amp;\u0026amp;a); }; /* using animals std:vector\u0026lt;animal\u0026gt;; animals as; as.emplace_back(dog{1)); as.emplace_back(cat{1)); as.emplace_back(Husky{2}); as.emplace_back(Siamese{3}); as.emplace_back(Bulldog{6}); for(const auto\u0026amp;a as){ ca11(a,4); } */ :[^01] ref: fr1vol-策略模式-知乎 ","permalink":"https://yangly0.github.io/posts/output/2025/20250120225031/","summary":"\u003cp\u003e摘要：一种设计模式——策略模式！\u003c/p\u003e","title":"设计模式之策略模式"},{"content":"摘要：一种特殊的设计模式！\nPIMPL 模式（Pointer to Implementation，又称 Opaque Pointer 模式）是一种 C++ 编程技术，其核心思想是将类的实现细节从公共接口中分离出来，通过指向实现类的指针来实现类的具体功能。\nPIMPL 模式可以提高二进制兼容性，减少编译依赖，并有效地隐藏类的实现细节。\nQt 是 PIMPL 模式的典型应用框架之一。Qt 的许多核心类（如 QWidget、QObject、QFile 等）都使用 PIMPL 模式来封装实现细节，从而提高类的封装性和 ABI 稳定性。\n:[^01] ref: jjb-coder-PIMPL 模式-CSDN ","permalink":"https://yangly0.github.io/posts/output/2025/20250120223603/","summary":"\u003cp\u003e摘要：一种特殊的设计模式！\u003c/p\u003e","title":"pimpl模式"},{"content":"摘要：虚函数性能问题的原因和解决方案。\n原文in-c-why-and-how-are-virtual-functions-slower?抛出了虚函数性能问题，参考文章link，作者做了实验，结论：\n1、重定向基本上不影响性能。\n2、根本原因：（1）编译器在编译时通常并不知道它将要调用哪个函数，所以它不能被内联优化和其它很多优化，因此就会增加很多无意义的指令（准备寄存器、调用函数、保存状态等）；（2）虚函数有很多实现方法，那分支预测的成功率也会降低很多，分支预测错误也会导致程序性能下降。\n分支预测：C++分支预测提示是一种编译器优化技术，用于提高程序在执行过程中分支语句的预测准确性，从而提高程序的性能。\n如何解决该问题？几个思路，\n使用访问者模式来使类层次结构可扩展； 使用普通模板替代继承和虚函数； C++20中的concepts用来替代面向对象代码； 使用variants替代虚函数或模板方法。 ","permalink":"https://yangly0.github.io/posts/output/2025/20250119211049/","summary":"\u003cp\u003e摘要：虚函数性能问题的原因和解决方案。\u003c/p\u003e","title":"虚函数为什么比较慢？"},{"content":"摘要：一次非常非常难的coredump排查经历！\nOTA3交付阶段，出现多次功能coredump情况，由于项目交付紧急，需要立即成立专项小组分析并解决该问题。\n通常发生coredump情况，系统会存在core文件。但不绝对，如果系统没有设置core文件生成机制，这种情况就需要额外下发debug版本复现压测。\n因此，在存在core文件的情况下，我们可以直接解析core文件，通过core文件定义到具体程序崩溃在哪一行，正常修改该问题即可。注意不同平台的core文件解析方式不一样。\n但是，这次core文件有些特殊，采用的是google的breakpad工具生成mini-core文件，同时由于历史原因编译选项未增加-g选项，导致堆栈信息不全，无法具体定位在哪一行，造成无法确定原因，至于为什么不全开始怀疑时是-g编译选项的原因，但是增加-g后也无效，后面又怀疑-O2影响-g则把-g改为-g3，依然无效，暂时无法解决就搁置了。仅能显示崩溃在libc.so中stl的vector的new_alloctor.h文件的114行以及崩溃的信号SIGSEGV信息，通过前者信息查阅源码知道崩溃在new开辟内存空间，通过后者信息知道本次崩溃是段错误，无效地址。\n从以上信息，我们当时怀疑几个点：第一个点是多线程问题，第二个点是内存踩空，第三个点是内存不够。因此，制定了几个相应行动项，一是增加-g3编译选项和录制top信息并持续压测复现，二是正向代码走读且要求部门专家一起评审，三是回退近期提交代码。\n巧合的是，压测复现一次，我们根据复现日志发现free从2000+M降低到200+M，正好此时进程崩溃，我们误以为是内存不够，我们功能调用new接口失败。但是后面确定cache内存还有4000M+，应该可以继续分配，同时系统正常运行时的free内存也保持在200M+，因此该结论不成立。\n正向走读代码，我们发现几个问题：\n多线程并发问题，原因是一个月前发现该问题并修复，初步怀疑没有修复完全，代码上发现通过unique_lock来实现加锁。但是多个任务去拿该锁时，会拷贝该唯一锁，正常来说同一个任务的互斥量一致，如果已经被锁了，会阻塞任务，但当时分析拷贝操作可能存在先解锁再加锁的情况，可后面测试该操作发现由于编译优化，直接替换，发现无问题。后面还怀疑一种情况，唯一锁可能会构造失败，造成锁失败，从而导致需要try_lock校验一下，但未验证。可惜，后面我们根据复现日志，发现没有函数重入问题，调用关系正常，暂时无法继续。第二怀疑点是接受数据和任务调度是异步关系，二者存在线程安全问题，正向走读代码，所有处理都在任务调度线程，接受数据线程只做状态记录，故也未发现问题。\n1 2 3 4 unique_lock\u0026lt;mutex\u0026gt; a = [this](){ unique_lock\u0026lt;mutex\u0026gt; lck(m_mtx); return lck; }; 移动拷贝风险，常引用传入参数，但是强转其类型，并用移动拷贝参数，造成改变外部数据未空，当外部数据再次使用，可能存在无效风险。\n1 2 3 4 void func(const T\u0026amp; t){ T t = std::cast\u0026lt;T\u0026amp;\u0026gt;(t); m_t = std::move(t); } 运行阶段，vector频繁触发扩充，会导致一定程度加速内存碎片化，如果数据过大可能在某一次扩容的时候没有连续空间出现该问题，但是有一点差异是扩容申请内存失败应该抛std::bad_alloc异常，不捕获的化进程会SIGABRT。同时，扩容底层会有内存空间拷贝影响性能。\n在以上步骤无效的情况下，我们针对以上几个风险点，做了一些正向修复，一是对于vector提前reverse分配内存空间，二是上层调动接口，增加trycatch，尝试捕获stl异常。\n终章，大概率断定是内存空间被踩，造成进程崩溃，但无法确定被谁踩，暂时无法复现，就不管了。\n","permalink":"https://yangly0.github.io/posts/output/2025/20250118232106/","summary":"\u003cp\u003e摘要：一次非常非常难的coredump排查经历！\u003c/p\u003e","title":"记录一次coredump排查经历！"},{"content":"摘要：本文介绍了如何通过hugo 快速搭建一个博客网站，然后设置PaperMod 主题，最后构建一个Github自动发布的博客系统。\n0x01 快速开始 1、软件安装：软件包链接Releases · gohugoio/hugo，建议安装带extended的扩展版本。\n1 2 3 4 5 6 # 下载 wget hugo_extended_0.xxx.x_linux-amd64.deb # 安装 sudo dpkg -i hugo_extended_0.xxx.x_linux-amd64.deb # 验证 hugo version 2、博客发布，访问http://localhost:1313/，查看渲染的博客内容。\n1 2 3 4 5 6 7 8 # 创建博客站点，yaml配置方式，默认是toml配置方式 hugo new site blog --format yaml # 进入博客 cd blog # 创建文章 hugo new posts/first_post.md # 博客发布 hugo server --disableFastRender --navigateToChanged --environment pruction --bind 0.0.0.0 0x02 适配主题 1、主题安装，主题库链接hugo-PaperMod，其他主题可以参考themes。\n1 2 3 4 5 6 7 8 9 # 进入博客 cd blog # 下载主题 git init git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --init --recursive 2、主题适配，参考hugo-PaperMod文档，手动复制config.yml内容到 hugo.yaml，注意提前备份hugo.yaml。\n3、自定义参数，按自己需求，修改hugo.yaml内容的全局配置、菜单配置、页面配置等。\n1 2 3 4 5 6 baseURL: \u0026#34;...\u0026#34; title: \u0026#34;...\u0026#34; copyright: \u0026#34;...\u0026#34; menu: ... 4、数学公式，PaperMod主题不支持公式渲染，需要手动适配，参考PaperMod Math Typesetting。注意，需要在hugo.yaml增加属性math: true。\n5、评论系统，todo。\n0x03 部署博客 参考link，Github个人网页上部署Hugo博客，每次提交内容到博客仓库Blog（Hugo搭建的仓库），博客仓库Blog会同步信息到个人页面仓库xxx.github.io，并发布网页。\n1、增加一个忽略文件.gitignore，目的是屏蔽本地渲染内容同步到远程仓库，内容如下：\n1 2 3 4 5 6 node_modules/ build/ public/ resources/ .hugo_build.lock 2、增加一个发布脚步hugo-blog.sh，目的是本地发布可以运行./hugo-blog.sh，内容如下：\n1 hugo server --disableFastRender --navigateToChanged --environment pruction --bind 0.0.0.0 3、登录Github网站，网页端创建一个==空仓库==，同步本地blog仓库到远程仓库，操作步骤如下：\n1 2 3 4 5 6 7 cd blog # 到站点文件夹 git init git add . git branch -M main # https://github.com/xxx/blog.git 修改为实际远程仓库链接 git remote add origin https://github.com/xxx/blog.git git push -u origin main 4、登录Github网站，创建个人页面xxx.github.io==空仓库==（第一个字段需要和你账号同名），用于构建github pages。\n5、创建Token密钥，选择Github账号，选择Settings，选择Developer Setting，选择Personal access tokens，选择Token(classic)，点击右上角的Generate new token创建密钥，选择Generate new token(classic)，Note为GP_DEPLOY_TOKEN，勾选repo和workflow，点击Generate token生成token密钥。\n6、配置博客Blog仓库的权限，选择Settings，选择Secrets and Variables，选择Actions，点击New repository secret创建密钥，Name写GP_DEPLOY_TOKEN，Secret填写生成的token密钥。\n7、配置博客Blog仓库的同步Action脚步，增加.github/workflows/deploy-hugo.yml文件，需要修改external_repository字段为个人账号，具体内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 name: Deploy hugo on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-latest concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.GP_DEPLOY_TOKEN }} external_repository: XXX/XXX.github.io publish_branch: main publish_dir: ./public commit_message: ${{ github.event.head_commit.message }} 8、配置博客Blog仓库的主题更新Action脚步，定时更新主题，增加.github/workflows/update-theme.yml文件，具体内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 name: Update theme # Controls when the workflow will run on: schedule: # Update theme automatically everyday at 00:00 UTC - cron: \u0026#34;0 0 * * *\u0026#34; # Allows you to run this workflow manually from the Actions tab workflow_dispatch: jobs: Update-PaperMod: runs-on: ubuntu-latest permissions: write-all steps: - name: Check out repository code uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 - name: Update theme run: git submodule update --remote --merge themes/PaperMod - name: Change remote origin run: | git remote remove origin git remote add origin https://github.com/Yangly0/blog.git - name: Commit changes uses: stefanzweifel/git-auto-commit-action@v4 with: branch: main commit_message: \u0026#39;:arrow_up: Chore(theme): update PaperMod version\u0026#39; commit_author: \u0026#39;github-actions[bot] \u0026lt;github-actions[bot]@users.noreply.github.com\u0026gt;\u0026#39; push_options: \u0026#39;--set-upstream\u0026#39; 9、提交deploy-hugo.yml和update-theme.yml远程博客Blog仓库，并自动发布到个人网页xxx.github.io仓库，访问xxx.github.io网站查看个人博客，具体操作如下：\n1 2 3 4 cd blog git add . git commit -m \u0026#34;feat: add workflow\u0026#34; git push origin main 0x04 撰写博客 1、常见文章，即blog/content/posts文件夹下创建md文件完成，然后写入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 --- date: \u0026#39;2024-11-24T02:02:24+08:00\u0026#39; draft: false title: \u0026#39;First_post\u0026#39; --- 摘要：abstract \u0026lt;!--more--\u0026gt; ## 标题1 正文 2、设置前置参数，在文章内容前面添加 yaml、toml 或者 json 格式的参数，配置文章相关属性。\n1 2 3 4 5 6 --- date: \u0026#39;2024-11-24T02:02:24+08:00\u0026#39; draft: false title: \u0026#39;First_post\u0026#39; ... --- 3、设置摘要，通过\u0026lt;!--more--\u0026gt;隔离摘要和内容，并且把摘要显示到预览块。\n1 2 3 4 5 摘要：demo \u0026lt;!--more--\u0026gt; 正文 4、博客内容，根据需求，自定义内容。\n5、发布博客，只需要提交到远程仓库，自动发布到个人页面，操作如下：\n1 2 3 git add . git commit -m \u0026#34;feat: add posts\u0026#34; git push origin main 参考","permalink":"https://yangly0.github.io/posts/output/2024/20241123215151/","summary":"\u003cp\u003e摘要：本文介绍了如何通过hugo 快速搭建一个博客网站，然后设置PaperMod 主题，最后构建一个Github自动发布的博客系统。\u003c/p\u003e","title":"如何搭建一个博客系统？"}]